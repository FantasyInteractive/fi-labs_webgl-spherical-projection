// Generated by CoffeeScript 1.4.0

/*
#============================================================
#
# Array augmentation.
#
# @author Matthew Wagerfield
#
#============================================================
*/


/*
# Removes an element from an array.
# @param {Object} element Element to remove.
*/


/* --------------------------------------------
     Begin Math.coffee
--------------------------------------------
*/


/*
#============================================================
#
# Math augmentation.
#
# @author Matthew Wagerfield
#
#============================================================
*/


(function() {
  var Canvas, Class, Codepen, Color, Colour, DEBUG, DEMO, DEMOS, DOGTAG, Ease, Layout, Map, PROJECT, Pathfinder, Physics, SHADERS, SIMPLEX_NOISE, STATS, TERRAIN_UTILS, TrackballControls, UTILS, Utils, WIREFRAME_EDGE_DETECTION, log, moduleKeywords, namespace, warn,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Math.PI2 = Math.PI * 2;

  Math.PIH = Math.PI / 2;

  Math.PIR = 180 / Math.PI;

  Math.PID = Math.PI / 180;

  /*
  # Converts radians to degrees.
  # @param {number} radians The radians to convert.
  # @return {number} The value in degrees.
  */


  Math.radiansToDegrees = function(radians) {
    return radians * Math.PIR;
  };

  /*
  # Converts degrees to radians.
  # @param {number} degrees The degrees to convert.
  # @return {number} The value in radians.
  */


  Math.degreesToRadians = function(degrees) {
    return degrees * Math.PID;
  };

  /*
  # Normalises a given value.
  # @param {number} value The value to normalise.
  # @param {number} min The minimum value in the range.
  # @param {number} max The maximum value in the range.
  # @return {value} The normalised number.
  */


  Math.normalise = function(value, min, max) {
    if (min == null) {
      min = 0;
    }
    if (max == null) {
      max = 1;
    }
    return (value - min) / (max - min);
  };

  Math.normalize = Math.normalise;

  /*
  # Interpolates between two values by a given multiplier.
  # @param {number} value The multiplier value.
  # @param {number} min The minimum value in the range.
  # @param {number} max The maximum value in the range.
  # @return {value} The interpolated number.
  */


  Math.interpolate = function(value, min, max) {
    return min + (max - min) * value;
  };

  /*
  # Maps a value within a certain range to another range.
  # @param {number} value The value to map.
  # @param {number} min1 The minimum value in the first range.
  # @param {number} max1 The maximum value in the first range.
  # @param {number} min2 The minimum value in the second range.
  # @param {number} max2 The maximum value in the second range.
  # @return {value} The mapped number.
  */


  Math.map = function(value, min1, max1, min2, max2) {
    return Math.interpolate(Math.normalise(value, min1, max1), min2, max2);
  };

  /*
  # Clamps a number within a specified range.
  # @param {number} value The value to clamp.
  # @param {number} min The minimum value.
  # @param {number} max The maximum value.
  # @return {value} The clamped number.
  */


  Math.clamp = function(value, min, max) {
    value = Math.max(value, min);
    value = Math.min(value, max);
    return value;
  };

  /*
  # Return the sign of the value.
  # @param {number} value The number.
  # @return {value} 1 or -1 depending on the sign.
  */


  Math.sign = function(value) {
    if (value >= 0) {
      return 1;
    } else {
      return -1;
    }
  };

  /*
  # Generates a random number within a specified range.
  # @param {number} min Minimum number in the range.
  # @param {number} max Maximum number in the range.
  # @param {boolean} round Whether or not to round the generated value.
  # @return {number} Random number within the specified range.
  */


  Math.randomInRange = function(min, max, round) {
    var value;
    if (round == null) {
      round = false;
    }
    value = Math.map(Math.random(), 0, 1, min, max);
    if (round) {
      value = Math.round(value);
    }
    return value;
  };

  /*
  # Projects a geographic coordinate into a 3D vertex.
  # @param {number} x The horizontal component.
  # @param {number} y The vertical component.
  # @param {number} radius The length of the vector.
  # @return {THREE.Vector3} Projected vector coordinate.
  */


  Math.project = function(x, y, radius) {
    var cosX, cosY, sinX, sinY, z;
    if (radius == null) {
      radius = 1;
    }
    x = Math.degreesToRadians(x);
    y = Math.degreesToRadians(y);
    sinX = Math.sin(x);
    cosX = Math.cos(x);
    sinY = Math.sin(y);
    cosY = Math.cos(y);
    x = -radius * cosY * cosX;
    y = radius * sinY;
    z = radius * cosY * sinX;
    return [x, y, z];
  };

  /* --------------------------------------------
       Begin Ease.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Easing functions.
  #
  # @param {number} t Time.
  # @param {number} d Duration.
  # @param {number} b Beginning value.
  # @param {number} c Total change.
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  Ease = (function() {
    /*
      #========================================
      # Quadratic
      #========================================
    */

    function Ease() {}

    Ease.quadIn = function(t, d, b, c) {
      return c * (t /= d) * t + b;
    };

    Ease.quadOut = function(t, d, b, c) {
      return -c * (t /= d) * (t - 2) + b;
    };

    Ease.quadInOut = function(t, d, b, c) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t + b;
      }
      return -c / 2 * ((--t) * (t - 2) - 1) + b;
    };

    /*
      #========================================
      # Cubic
      #========================================
    */


    Ease.cubicIn = function(t, d, b, c) {
      return c * (Math.pow(t / d, 3)) + b;
    };

    Ease.cubicOut = function(t, d, b, c) {
      return c * ((Math.pow(t / d - 1, 3)) + 1) + b;
    };

    Ease.cubicInOut = function(t, d, b, c) {
      if ((t /= d / 2) < 1) {
        return c / 2 * (Math.pow(t, 3)) + b;
      }
      return c / 2 * ((Math.pow(t - 2, 3)) + 2) + b;
    };

    /*
      #========================================
      # Quartic
      #========================================
    */


    Ease.quartIn = function(t, d, b, c) {
      return c * (Math.pow(t / d, 4)) + b;
    };

    Ease.quartOut = function(t, d, b, c) {
      return -c * ((Math.pow(t / d - 1, 4)) - 1) + b;
    };

    Ease.quartInOut = function(t, d, b, c) {
      if ((t /= d / 2) < 1) {
        return c / 2 * (Math.pow(t, 4)) + b;
      }
      return -c / 2 * ((Math.pow(t - 2, 4)) - 2) + b;
    };

    /*
      #========================================
      # Quintic
      #========================================
    */


    Ease.quintIn = function(t, d, b, c) {
      return c * (Math.pow(t / d, 5)) + b;
    };

    Ease.quintOut = function(t, d, b, c) {
      return c * ((Math.pow(t / d - 1, 5)) + 1) + b;
    };

    Ease.quintInOut = function(t, d, b, c) {
      if ((t /= d / 2) < 1) {
        return c / 2 * (Math.pow(t, 5)) + b;
      }
      return c / 2 * ((Math.pow(t - 2, 5)) + 2) + b;
    };

    /*
      #========================================
      # Exponential
      #========================================
    */


    Ease.expoIn = function(t, d, b, c) {
      return c * (Math.pow(2, 10 * (t / d - 1))) + b;
    };

    Ease.expoOut = function(t, d, b, c) {
      return c * (-(Math.pow(2, -10 * t / d)) + 1) + b;
    };

    Ease.expoInOut = function(t, d, b, c) {
      if ((t /= d / 2) < 1) {
        return c / 2 * (Math.pow(2, 10 * (t - 1))) + b;
      }
      return c / 2 * (-(Math.pow(2, -10 * --t)) + 2) + b;
    };

    return Ease;

  })();

  /* --------------------------------------------
       Begin Utils.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Generic Utilities
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  #
  #============================================================
  */


  Utils = (function() {
    /*
      # Generates a GUID.
      # @param {number} length The length of the guid.
      # @param {string} prefix String to prefix the GUID with.
      # @return {string} The generated GUID.
    */

    function Utils() {}

    Utils.guid = function(length, prefix) {
      var guid, i;
      if (length == null) {
        length = 8;
      }
      if (prefix == null) {
        prefix = 'eco';
      }
      guid = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
          _results.push((Math.random().toFixed(1)).substr(2));
        }
        return _results;
      })();
      guid = "" + prefix + (guid.join(''));
      return guid;
    };

    /*
      # Returns THREE blending hash object.
      # @return {object} Blending hash object.
    */


    Utils.blending = {
      NoBlending: THREE.NoBlending,
      NormalBlending: THREE.NormalBlending,
      AdditiveBlending: THREE.AdditiveBlending,
      SubtractiveBlending: THREE.SubtractiveBlending,
      MultiplyBlending: THREE.MultiplyBlending,
      CustomBlending: THREE.CustomBlending
    };

    /*
      # Returns THREE destination hash object.
      # @return {object} Blending destination hash object.
    */


    Utils.destination = {
      ZeroFactor: THREE.ZeroFactor,
      OneFactor: THREE.OneFactor,
      SrcColorFactor: THREE.SrcColorFactor,
      OneMinusSrcColorFactor: THREE.OneMinusSrcColorFactor,
      SrcAlphaFactor: THREE.SrcAlphaFactor,
      OneMinusSrcAlphaFactor: THREE.OneMinusSrcAlphaFactor,
      DstAlphaFactor: THREE.DstAlphaFactor,
      OneMinusDstAlphaFactor: THREE.OneMinusDstAlphaFactor
    };

    /*
      # Adds leading zeros to a given number.
      # @param {number} number The number to add the zeros to.
      # @param {number} length The number of zeros to add.
      # @return {string} The number with the leading zeros added.
    */


    Utils.leadingZeros = function(number, length) {
      var n, _i, _ref;
      number += '';
      if (number.length > length) {
        return number;
      }
      for (n = _i = _ref = number.length; _ref <= length ? _i < length : _i > length; n = _ref <= length ? ++_i : --_i) {
        number = '0' + number;
      }
      return number;
    };

    /*
      # Separates a number with commas at every 1000 units.
      # @return {string} The formatted number as a string.
    */


    Utils.comify = function(string) {
      var expression, x, x1, x2;
      string += '';
      x = string.split('.');
      x1 = x[0];
      x2 = x.length > 1 ? '.' + x[1] : '';
      expression = /(\d+)(\d{3})/;
      while (expression.test(x1)) {
        x1 = x1.replace(expression, '$1' + ',' + '$2');
      }
      return x1 + x2;
    };

    /*
      # Projects a Vector3 in a THREE Scene to a 2D coordinate.
      # @param {object} center An object with the dimensions of the screen center.
      # @param {object} camera A THREE Camera.
      # @param {object} object The parent THREE Object3D of the vector.
      # @param {object} vector A THREE Vector3 to project.
      # @return {object} The projected coordinate.
    */


    Utils.project = function(center, camera, object, vector) {
      var clone, coordinate, graph, matrix, projector;
      coordinate = {
        x: 0,
        y: 0
      };
      if (!((center != null) && (camera != null) && (object != null) && (vector != null))) {
        return coordinate;
      }
      graph = this.buildGraph(object);
      matrix = new THREE.Matrix4;
      this.buildMatrix(graph, matrix);
      matrix.multiplyVector3(clone = vector.clone());
      projector = new THREE.Projector;
      projector.projectVector(clone, camera);
      coordinate.x = Math.round(center.x + clone.x * center.x);
      coordinate.y = Math.round(center.y - clone.y * center.y);
      return coordinate;
    };

    /*
      # Adds ellipsis to an element at the point where the height is exceeded.
      # @param {jQuery} $elements jQuery selection.
      # @param {number} height The maximum height.
      # @param {number} max The maximum characters to restrict when using fallback method.
    */


    Utils.ellipsis = function($elements, height, max) {
      var expression;
      if (max == null) {
        max = 200;
      }
      expression = /\W*\s(\S)*$/g;
      $elements.each(function(index, item) {
        var $element, append, fallback, string;
        $element = $(item);
        string = $element.text();
        fallback = false;
        append = false;
        while ($element.outerHeight() > height && max > 0) {
          append = true;
          if (!fallback && expression.test(string)) {
            $element.text(function(index, text) {
              string = text.replace(expression, "");
              return string;
            });
          } else {
            fallback = true;
            $element.text(function(index, text) {
              string = text.substr(0, max);
              return string;
            });
            max -= 5;
          }
        }
        if (append) {
          return $element.text(string + "...");
        }
      });
    };

    /*
      # Adds ellipsis to an element at the point where the height is exceeded.
      # @param {THREE.Object3D} object The nested object.
      # @param {THREE.Object3D} height The root object to build the graph up to.
      # @return {array} Array of objects from the root to the object.
    */


    Utils.buildGraph = function(object, root) {
      var graph;
      graph = [object];
      while ((object.parent != null) && object !== root) {
        graph.push(object = object.parent);
      }
      return graph.reverse();
    };

    /*
      # Adds ellipsis to an element at the point where the height is exceeded.
      # @param {array} graph Array of THREE.Object3D objects.
      # @param {THREE.Matrix4} matrix Matrix to apply graph transformations to.
      # @return {THREE.Matrix4} The transformed matrix.
    */


    Utils.buildMatrix = function(graph, matrix) {
      var object, _i, _len;
      matrix.identity();
      for (_i = 0, _len = graph.length; _i < _len; _i++) {
        object = graph[_i];
        matrix.multiplySelf(object.matrix);
      }
      return matrix;
    };

    return Utils;

  })();

  this.Utils = Utils;

  /* --------------------------------------------
       Begin Color.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Collection of colour methods.
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  #
  #============================================================
  */


  Color = (function() {
    /*
      # Converts a HEX string to an RGB object.
      # @param {number} hex Hex value of the color.
      # @param {number} range Range of the color.
      # @return {object} The Color.
    */

    function Color() {}

    Color.rgb = function(hex, range) {
      var b, g, hexString, r;
      if (range == null) {
        range = 255;
      }
      hexString = hex.replace('#', '');
      return {
        r: (r = (parseInt(hexString.substring(0, 2), 16)) / range),
        g: (g = (parseInt(hexString.substring(2, 4), 16)) / range),
        b: (b = (parseInt(hexString.substring(4, 6), 16)) / range),
        colors: [r, g, b],
        rgb: "rgb(" + r + "," + g + "," + b + ")",
        hex: hex
      };
    };

    /*
      # Converts a HEX string to an RGB object.
      # @param {number} hex Hex value of the color.
      # @param {number} alpha Opacity of the color.
      # @param {number} range Range of the color.
      # @return {object} The Color.
    */


    Color.rgba = function(hex, alpha, range) {
      var color;
      if (range == null) {
        range = 255;
      }
      color = this.rgb(hex, range);
      color.a = alpha;
      color.colors.push(alpha);
      color.rgba = "rgba(" + color.r + "," + color.g + "," + color.b + "," + color.a + ")";
      return color;
    };

    /*
      # Converts a RGB to HSL.
      # @param {number} r Red value of the color.
      # @param {number} g Green value of the color.
      # @param {number} b Blue value of the color.
      # @return {object} HSL color object.
    */


    Color.hsl = function(r, g, b) {
      var d, h, l, max, min, s;
      r /= 255;
      g /= 255;
      b /= 255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      d = max - min;
      h = 0;
      s = 0;
      l = (max + min) / 2;
      if (max !== min) {
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
        }
        h /= 6;
      }
      return {
        h: h,
        s: s,
        l: l
      };
    };

    /*
      # Converts a RGB to HSV.
      # @param {number} r Red value of the color   (0 - 255).
      # @param {number} g Green value of the color (0 - 255).
      # @param {number} b Blue value of the color  (0 - 255).
      # @return {object} HSV color object (0 - 1).
    */


    Color.hsv = function(r, g, b) {
      var d, h, max, min, s, v;
      r /= 255;
      g /= 255;
      b /= 255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      d = max - min;
      h = 0;
      s = max === 0 ? 0 : d / max;
      v = max;
      if (max !== min) {
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
        }
        h /= 6;
      }
      return {
        h: h,
        s: s,
        v: v
      };
    };

    /*
      # Returns a colour in the form of a THREE.Vector3.
      # @param {string} hex String representation of a hex colour - #FF0000.
      # @return {THREE.Vector3} The generated colour as a THREE.Vector3.
    */


    Color.vector3 = function(hex) {
      var color, vector;
      color = Color.rgb(hex);
      vector = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(THREE.Vector3, color.colors, function(){});
      return vector;
    };

    /*
      # Returns a colour in the form of a THREE.Vector4.
      # @param {string} hex String representation of a hex colour - #FF0000.
      # @param {number} opacity The opacity value 0 - 1.
      # @return {THREE.Vector4} The generated colour as a THREE.Vector4.
    */


    Color.vector4 = function(hex, opacity) {
      var color, vector;
      color = Color.rgba(hex, opacity);
      vector = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(THREE.Vector4, color.colors, function(){});
      return vector;
    };

    return Color;

  })();

  this.Color = this.Colour = Colour = Color;

  /* --------------------------------------------
       Begin Canvas.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Collection of canvas methods.
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  #
  #============================================================
  */


  Canvas = (function() {
    /*
      # Parses an image data object and formats the RGBA values.
      # @param {data} imageData The image data object to parse.
      # @param {boolean} normalise Whether or not to normalise the data.
      # @return {array} Formatted array of RGBA objects.
    */

    function Canvas() {}

    Canvas.format = function(imageData, normalise, ignore, scale) {
      var STEP, a, b, data, g, h, height, hsv, pixels, r, rgb, rgba, s, v, width, x, y, _i, _j;
      if (normalise == null) {
        normalise = false;
      }
      if (ignore == null) {
        ignore = false;
      }
      if (scale == null) {
        scale = 1;
      }
      STEP = 1 / scale;
      data = imageData.data;
      width = imageData.width;
      height = imageData.height;
      pixels = [];
      for (y = _i = 0; 0 <= height ? _i < height : _i > height; y = _i += STEP) {
        for (x = _j = 0; 0 <= width ? _j < width : _j > width; x = _j += STEP) {
          r = data[((width * y) + x) * 4 + 0];
          g = data[((width * y) + x) * 4 + 1];
          b = data[((width * y) + x) * 4 + 2];
          a = data[((width * y) + x) * 4 + 3];
          hsv = Color.hsv(r, g, b);
          h = hsv.h;
          s = hsv.s;
          v = hsv.v;
          hsv = h + s + v;
          if (normalise) {
            r /= 255;
            g /= 255;
            b /= 255;
            a /= 255;
          }
          rgba = r + g + b + a;
          rgb = r + g + b;
          if (!ignore || rgba) {
            pixels.push({
              x: x,
              y: y,
              r: r,
              g: g,
              b: b,
              a: a,
              rgb: rgb,
              rgba: rgba,
              h: h,
              s: s,
              v: v,
              hsv: hsv
            });
          }
        }
      }
      return pixels;
    };

    /*
      # Parses an image data object and formats the RGBA values.
      # @param {array} sourceImageData The source ImageData to set the values on.
      # @param {array} imageDataMultiplier Array of image data objects to multiply.
      # @param {array} channelMultiplier Array of channel multipliers for RGBA.
      # @return {array} Formatted array of RGBA objects.
    */


    Canvas.multiply = function(sourceImageData, imageDataMultiplier, channelMultiplier) {
      var data, height, imageData, length, p, width, _i, _j, _k, _len, _len1;
      if (channelMultiplier == null) {
        channelMultiplier = [1, 1, 1, 1];
      }
      data = sourceImageData.data;
      width = sourceImageData.width;
      height = sourceImageData.height;
      length = sourceImageData.data.length;
      for (_i = 0, _len = imageDataMultiplier.length; _i < _len; _i++) {
        imageData = imageDataMultiplier[_i];
        if (imageData.width !== width || imageData.height !== height) {
          warn('Canvas.multiply: image data must be the same dimensions');
          return;
        }
      }
      for (p = _j = 0; _j < length; p = _j += 4) {
        for (_k = 0, _len1 = imageDataMultiplier.length; _k < _len1; _k++) {
          imageData = imageDataMultiplier[_k];
          data[p + 0] *= imageData.data[p + 0] / 255;
          data[p + 1] *= imageData.data[p + 1] / 255;
          data[p + 2] *= imageData.data[p + 2] / 255;
          data[p + 3] *= imageData.data[p + 3] / 255;
        }
        data[p + 0] *= channelMultiplier[0];
        data[p + 1] *= channelMultiplier[1];
        data[p + 2] *= channelMultiplier[2];
        data[p + 3] *= channelMultiplier[3];
      }
      return sourceImageData;
    };

    return Canvas;

  })();

  this.Canvas = Canvas;

  /* --------------------------------------------
       Begin Map.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Map utility methods.
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  # @author Zaidin Amiot (Fantasy Interactive)
  #
  #============================================================
  */


  Map = (function() {
    /*
      # Projects a geographic coordinate into a 3D vertex.
      # @param {number} latitude The vertical component.
      # @param {number} longitude The horizontal component.
      # @param {number} length The length of the vector.
      # @return {THREE.Vector3} Projected vector coordinate.
    */

    var _this = this;

    function Map() {}

    Map.project = function(latitude, longitude, length) {
      var cosPhi, cosTheta, sinPhi, sinTheta, x, y, z;
      if (length == null) {
        length = 1;
      }
      latitude = Math.degreesToRadians(latitude);
      longitude = Math.degreesToRadians(longitude);
      sinPhi = Math.sin(latitude);
      cosPhi = Math.cos(latitude);
      sinTheta = Math.sin(longitude);
      cosTheta = Math.cos(longitude);
      x = -length * cosPhi * cosTheta;
      y = length * sinPhi;
      z = length * cosPhi * sinTheta;
      return new THREE.Vector3(x, y, z);
    };

    /*
      # Projects a latitude into a value in pixel.
      # @param {number} latitude The vertical component.
      # @param {number} height The height of the map.
      # @return {number} Projected number in pixel.
    */


    Map.projectLatitude = function(latitude, height) {
      return Math.round(height * Math.map(latitude, -90, 90, 1, 0));
    };

    /*
      # Projects a longitude into a value in pixel.
      # @param {number} longitude The vertical component.
      # @param {number} width The height of the map.
      # @return {number} Projected number in pixel.
    */


    Map.projectLongitude = function(longitude, width) {
      return Math.round(width * Math.map(longitude, -180, 180, 0, 1));
    };

    /*
      # Returns two points in clip space using geographic coordinate on 2D grid.
      # @param {coordinate} start latitude/longitude of the start point.
      # @param {coordinate} end latitude/longitude of the end point.
      # @param {int} horizontal horizontal length of the grid.
      # @param {int} vertical vertical length of the grid.
      # @return {array} Normalised vector coordinate for the two points.
    */


    Map.clipSpace = function(start, end, horizontal, vertical) {
      var delta, distance, east, incrementX, incrementY, length, north, south, west, xAxis, yAxis;
      delta = {
        x: end.longitude - start.longitude,
        y: end.latitude - start.latitude
      };
      length = {
        x: Math.abs(delta.x),
        y: Math.abs(delta.y)
      };
      incrementX = Math.ceil(horizontal / 2.5);
      incrementY = Math.ceil(vertical / 2.5);
      xAxis = Math.ceil(horizontal / 2);
      yAxis = Math.ceil(vertical / 2);
      north = Math.randomInt(incrementY, Math.ceil(incrementY / 2));
      south = vertical - Math.randomInt(incrementY, Math.ceil(incrementY / 2));
      east = Math.randomInt(incrementX, Math.ceil(incrementX / 2));
      west = horizontal - Math.randomInt(incrementX, Math.ceil(incrementX / 2));
      if (length.x > length.y) {
        if (delta.x > 0) {
          start.x = east;
          end.x = west;
        } else {
          start.x = west;
          end.x = east;
        }
        distance = Math.randomInt(Math.ceil((vertical - incrementY) / 2), 1);
        start.y = yAxis + distance * Math.sign(delta.y);
        end.y = yAxis - distance * Math.sign(delta.y);
      } else {
        if (delta.y > 0) {
          start.y = south;
          end.y = north;
        } else {
          start.y = north;
          end.y = south;
        }
        distance = Math.randomInt(Math.ceil((horizontal - incrementX) / 2), 1);
        start.x = xAxis - distance * Math.sign(delta.x);
        end.x = xAxis + distance * Math.sign(delta.x);
      }
      return [start, end];
    };

    /*
      # Returns two random points on a 2D grid.
      # @param {int} horizontal horizontal length of the grid.
      # @param {int} vertical vertical length of the grid.
      # @return {array} Normalised vector coordinate for the two points.
    */


    Map.plotRoute = function(horizontal, vertical, paddingX, paddingY) {
      var a, b, east, end, north, positionX, positionY, south, start, west;
      if (paddingX == null) {
        paddingX = 0;
      }
      if (paddingY == null) {
        paddingY = 0;
      }
      a = Math.randomInt(1);
      b = Math.randomInt(1);
      north = paddingY;
      south = vertical - paddingY;
      east = paddingX;
      west = horizontal - paddingX;
      if (a === 0) {
        positionY = b === 0 ? [north, south] : [south, north];
        start = {
          x: Math.randomInRange(east, west, true),
          y: positionY[0]
        };
        end = {
          x: Math.randomInRange(east, west, true),
          y: positionY[1]
        };
      } else {
        positionX = b === 0 ? [east, west] : [west, east];
        start = {
          x: positionX[0],
          y: Math.randomInRange(north, south, true)
        };
        end = {
          x: positionX[1],
          y: Math.randomInRange(north, south, true)
        };
      }
      return [start, end];
    };

    /*
      # Calculate the distance between 2 points using their coordinates.
      # @param {object} start Starting point.
      # @param {object} end Destination.
      # @return {float} Distance in km.
    */


    Map.calculateDistance = function(start, end) {
      var R, a, c, deltaLatitude, deltaLongitude, latitude_1, latitude_2, longitude_1, longitude_2;
      R = 6371;
      latitude_1 = start.latitude;
      latitude_2 = end.latitude;
      longitude_1 = start.longitude;
      longitude_2 = end.longitude;
      deltaLatitude = Math.degreesToRadians(latitude_2 - latitude_1);
      deltaLongitude = Math.degreesToRadians(longitude_2 - longitude_1);
      latitude_1 = Math.degreesToRadians(latitude_1);
      latitude_2 = Math.degreesToRadians(latitude_2);
      a = Math.sin(deltaLatitude / 2) * Math.sin(deltaLatitude / 2) + Math.sin(deltaLongitude / 2) * Math.sin(deltaLongitude / 2) * Math.cos(latitude_1) * Math.cos(latitude_2);
      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    };

    return Map;

  }).call(this);

  this.Map = Map;

  /* --------------------------------------------
       Begin Pathfinder.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Pathfinder
  #
  # Collection of methods for Pathfinding.js.
  #
  # @requires underscore.js
  # @see http://underscorejs.org/
  #
  # @author Zaidin Amiot (Fantasy Interactive)
  #
  #============================================================
  */


  Pathfinder = (function() {
    /*
      #========================================
      # Constants
      #========================================
    */

    function Pathfinder() {}

    Pathfinder.algorithms = {
      AStar: Pathfinder.AStar = PF.AStarFinder,
      BiAStar: Pathfinder.BiAStar = PF.BiAStarFinder,
      BreadthFirst: Pathfinder.BreadthFirst = PF.BreadthFirstFinder,
      BiBreadthFirst: Pathfinder.BiBreadthFirst = PF.BiBreadthFirstFinder,
      BestFirst: Pathfinder.BestFirst = PF.BreadthFirstFinder,
      BiBestFirst: Pathfinder.BiBestFirst = PF.BiBestFirstFinder,
      Dijkstra: Pathfinder.Dijkstra = PF.DijkstraFinder,
      BiDijkstra: Pathfinder.BiDijkstra = PF.BiDijkstraFinder,
      JumpPoint: Pathfinder.JumpPoint = PF.JumpPointFinder
    };

    /*
      #========================================
      # Static Properties
      #========================================
    */


    Pathfinder.grid = null;

    Pathfinder.nodes = null;

    Pathfinder.finder = null;

    Pathfinder.horizontalSegments = null;

    Pathfinder.verticalSegments = null;

    Pathfinder.operations = [];

    /*
      #========================================
      # Static Methods
      #========================================
    */


    /*
      # Set the grid and the finder.
      # @param {number} horizontalSegments Number of horizontal segments.
      # @param {number} verticalSegments Number of vertical segments.
      # @param {constant} finder Type of pathfinding finder.
      # @param {object} options Options for the finder.
    */


    Pathfinder.initialise = function(horizontalSegments, verticalSegments, finder, options) {
      this.setGrid(horizontalSegments, verticalSegments);
      this.setFinder(finder, options);
      this.operations = [];
    };

    Pathfinder.addHookOnNode = function() {
      Object.defineProperty(PF.Node.prototype, 'opened', {
        get: function() {
          return this._opened;
        },
        set: function(value) {
          this._opened = value;
          Pathfinder.operations.push({
            x: this.x,
            y: this.y,
            attr: 'opened',
            value: value
          });
        }
      });
      return Object.defineProperty(PF.Node.prototype, 'closed', {
        get: function() {
          return this._closed;
        },
        set: function(value) {
          this._closed = value;
          Pathfinder.operations.push({
            x: this.x,
            y: this.y,
            attr: 'closed',
            value: value
          });
        }
      });
    };

    /*
      # Set the grid.
      # @param {number} horizontalSegments Number of horizontal segments.
      # @param {number} verticalSegments Number of vertical segments.
    */


    Pathfinder.setGrid = function(horizontalSegments, verticalSegments, matrix) {
      this.horizontalSegments = horizontalSegments;
      this.verticalSegments = verticalSegments;
      if (matrix == null) {
        matrix = [];
      }
      if (matrix.length === 0) {
        matrix = this.createMatrix();
      }
      this.nodes = this.horizontalSegments * this.verticalSegments;
      this.grid = new PF.Grid(this.horizontalSegments, this.verticalSegments, matrix);
    };

    /*
      # Create empty matrix.
      # @param {number} horizontalSegments Number of horizontal segments.
      # @param {number} verticalSegments Number of vertical segments.
      # @return {array} Return a bi-dimensional array filled with 0.
    */


    Pathfinder.createMatrix = function() {
      var i;
      return (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.verticalSegments; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (i = _j = 0, _ref1 = this.horizontalSegments; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
              _results1.push(0);
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
    };

    /*
      # Set the finder.
      # @param {constant} finder Type of pathfinding finder.
      # @param {object} options Options for the finder.
    */


    Pathfinder.setFinder = function(finder, options) {
      if (finder == null) {
        finder = this.AStar;
      }
      if (options == null) {
        options = {};
      }
      this.finder = new finder(options);
    };

    /*
      # Set walkable.
      # @param {array} node Simple tuple with x/y coordinates.
      # @param {boolean} state Walkable state of the grid.
    */


    Pathfinder.setWalkable = function(node, state) {
      if (state == null) {
        state = false;
      }
      if (!this.grid) {
        return;
      }
      this.grid.setWalkableAt(node[0], node[1], state);
    };

    /*
      # Return a solution.
      # @param {array} nodes Start and end nodes as a {x, y} object.
      # @return {array} Return an array of points.
    */


    Pathfinder.solution = function(start, end) {
      var node, solution;
      if (!this.grid) {
        return [];
      }
      solution = this.finder.findPath(start.x, start.y, end.x, end.y, this.grid.clone());
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = solution.length; _i < _len; _i++) {
          node = solution[_i];
          _results.push(this.coordinateToIndex(node));
        }
        return _results;
      }).call(this);
    };

    /*
      # Return a complex solution.
      # @param {array} nodes Start and end nodes as a {x, y} object.
      # @return {array} Return an array of points.
    */


    Pathfinder.complexify = function(start, end, complexity) {
      var domain, node, simple, _i, _len, _ref;
      if (complexity == null) {
        complexity = 0.5;
      }
      this.setGrid(this.horizontalSegments, this.verticalSegments);
      simple = this.solution(start, end);
      domain = simple.slice(1, -1);
      _ref = this.pickPoints(domain.length, Math.ceil(domain.length * complexity));
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        this.setWalkable(this.indexToCoordinate(domain[node]));
      }
      return this.solution(start, end);
    };

    /*
      # get coordinate in the matrix from index
      # @param {int} index Index of the node in the nodes collection.
      # @return {array} Return a tuple of coordinates.
    */


    Pathfinder.indexToCoordinate = function(index) {
      var x, y;
      x = index % this.horizontalSegments;
      y = Math.floor(index / this.horizontalSegments);
      return [x, y];
    };

    /*
      # get index from coordinates
      # @param {array} coordinate Tuple of coordinates.
      # @return {int} index Index of the node in the nodes collection.
    */


    Pathfinder.coordinateToIndex = function(coordinate) {
      return coordinate[0] + coordinate[1] * this.horizontalSegments;
    };

    /*
      # Return n random indexes in the collection.
      # @param {int} length Length of the collection.
      # @param {int} numbers Number of elements returned.
      # @return {array} Return an array of indexes.
    */


    Pathfinder.pickPoints = function(length, numbers) {
      var collection, data, _i, _results;
      if (length == null) {
        length = this.nodes;
      }
      if (numbers == null) {
        numbers = 2;
      }
      collection = (function() {
        _results = [];
        for (var _i = 0; 0 <= length ? _i < length : _i > length; 0 <= length ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
      data = [];
      while (data.length < numbers) {
        data = data.concat(collection.splice(Math.randomInt(length), 1));
      }
      return data;
    };

    return Pathfinder;

  }).call(this);

  /* --------------------------------------------
       Begin Physics.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Simple Physics.
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  #
  #============================================================
  */


  Physics = (function() {
    /*
      #========================================
      # Constants
      #========================================
    */

    var MAX, MIN;

    MIN = 0;

    MAX = 0.99;

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    Physics.prototype.reference = null;

    Physics.prototype.velocity = null;

    Physics.prototype.inertia = null;

    Physics.prototype.delta = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    function Physics(reference) {
      this.reference = reference;
      this.velocity = {};
      this.inertia = {};
      this.delta = {};
      return;
    }

    Physics.prototype.chase = function(target, friction, inertia) {
      var key, value;
      friction = Math.max(friction, MIN);
      friction = Math.min(friction, MAX);
      inertia = Math.max(inertia, MIN);
      inertia = Math.min(inertia, MAX);
      for (key in target) {
        value = target[key];
        this.delta[key] = target[key] - this.reference[key];
        this.velocity[key] = parseInt(this.velocity[key] || 0);
        this.velocity[key] = this.velocity[key] * inertia + this.delta[key] * (1 - friction);
        this.reference[key] += this.velocity[key];
        this.inertia[key] = this.velocity[key];
      }
    };

    Physics.prototype.drift = function(target, friction) {
      var key, value;
      friction = Math.max(friction, MIN);
      friction = Math.min(friction, MAX);
      for (key in target) {
        value = target[key];
        this.inertia[p] = (parseInt(this.inertia[p])) * (1 - friction);
        this.reference[p] += this.inertia[p];
      }
    };

    return Physics;

  })();

  /* --------------------------------------------
       Begin TrackballControls.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Trackball Controls for three.js
  #
  # @requires three.js
  # @see https://github.com/mrdoob/three.js/
  #
  # @requires jquery.js
  # @see http://jquery.com/
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  #
  #============================================================
  */


  TrackballControls = (function() {
    /*
      #========================================
      # Constants
      #========================================
    */

    var DELAY, X_AXIS, Y_AXIS, Z_AXIS;

    DELAY = 200;

    X_AXIS = new THREE.Vector3(1, 0, 0);

    Y_AXIS = new THREE.Vector3(0, 1, 0);

    Z_AXIS = new THREE.Vector3(0, 0, 1);

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    TrackballControls.prototype.$window = null;

    TrackballControls.prototype.$element = null;

    TrackballControls.prototype.object = null;

    TrackballControls.prototype.element = null;

    TrackballControls.prototype.dragging = null;

    TrackballControls.prototype.dragged = null;

    TrackballControls.prototype.roll = null;

    TrackballControls.prototype.pan = null;

    TrackballControls.prototype.current = null;

    TrackballControls.prototype.previous = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    function TrackballControls(object, element) {
      this.object = object;
      this.element = element;
      this.onMouseUp = __bind(this.onMouseUp, this);

      this.onMouseMove = __bind(this.onMouseMove, this);

      this.onMouseDown = __bind(this.onMouseDown, this);

      this.update = __bind(this.update, this);

      this.rotateAroundWorldAxis = __bind(this.rotateAroundWorldAxis, this);

      this.rotateAroundObjectAxis = __bind(this.rotateAroundObjectAxis, this);

      this.addEventListeners = __bind(this.addEventListeners, this);

      this.addControl = __bind(this.addControl, this);

      this.$window = $(window);
      this.$element = $(this.element);
      this.current = new THREE.Vector2;
      this.previous = new THREE.Vector2;
      this.roll = this.addControl(0.00025, 0.92);
      this.roll.velocity = new THREE.Vector2;
      this.roll.delta = new THREE.Vector2;
      this.pan = this.addControl(0.015, 0.98);
      this.pan.velocity = new THREE.Vector2;
      this.pan.delta = new THREE.Vector2;
      this.dragged = new signals.Signal;
      this.dragging = false;
      this.addEventListeners();
      return;
    }

    TrackballControls.prototype.addControl = function(speed, friction) {
      return {
        friction: friction,
        speed: speed,
        enabled: true
      };
    };

    TrackballControls.prototype.addEventListeners = function() {
      this.$element.on('mousedown', this.onMouseDown);
    };

    TrackballControls.prototype.rotateAroundObjectAxis = function(object, axis, radians) {
      var rotationObjectMatrix;
      rotationObjectMatrix = new THREE.Matrix4;
      rotationObjectMatrix.makeRotationAxis(axis.normalize(), radians);
      object.matrix.multiplySelf(rotationObjectMatrix);
      object.rotation.setEulerFromRotationMatrix(object.matrix);
    };

    TrackballControls.prototype.rotateAroundWorldAxis = function(object, axis, radians) {
      var rotationWorldMatrix;
      rotationWorldMatrix = new THREE.Matrix4;
      rotationWorldMatrix.makeRotationAxis(axis.normalize(), radians);
      rotationWorldMatrix.multiplySelf(object.matrix);
      object.matrix = rotationWorldMatrix;
      object.rotation.setEulerFromRotationMatrix(object.matrix);
    };

    TrackballControls.prototype.update = function() {
      if (this.pan.enabled) {
        this.pan.velocity.addSelf(this.pan.delta.multiplyScalar(this.pan.speed));
        this.object.position.x = this.pan.velocity.x;
        this.object.position.y = -this.pan.velocity.y;
        this.pan.velocity.multiplyScalar(this.pan.friction);
      }
      if (this.roll.enabled) {
        this.roll.velocity.addSelf(this.roll.delta.multiplyScalar(this.roll.speed));
        this.rotateAroundWorldAxis(this.object, X_AXIS, this.roll.velocity.y);
        this.rotateAroundWorldAxis(this.object, Y_AXIS, this.roll.velocity.x);
        this.roll.velocity.multiplyScalar(this.roll.friction);
      }
    };

    /*
      #========================================
      # Callbacks
      #========================================
    */


    TrackballControls.prototype.onMouseDown = function(event) {
      event.preventDefault();
      this.dragged.dispatch(this.dragging = true);
      this.$window.on('mouseup', this.onMouseUp);
      this.$window.on('mousemove', this.onMouseMove);
      this.current.set(event.pageX, event.pageY);
      this.previous.set(event.pageX, event.pageY);
    };

    TrackballControls.prototype.onMouseMove = function(event) {
      this.current.set(event.pageX, event.pageY);
      this.roll.delta.sub(this.current, this.previous);
      this.pan.delta.sub(this.current, this.previous);
      this.previous.copy(this.current);
    };

    TrackballControls.prototype.onMouseUp = function(event) {
      this.$window.off('mousemove', this.onMouseMove);
      this.$window.off('mouseup', this.onMouseUp);
      this.dragged.dispatch(this.dragging = false);
    };

    return TrackballControls;

  })();

  /* --------------------------------------------
       Begin Class.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Abstract Class
  #
  # Intergrates mixins into CoffeeScript classes.
  #
  # @author Matthew Wagerfield
  # @author Filip Michalowski
  # @example
  #
  #  # Object that properties will be added to the User class
  #  classProperties =
  #    find: (id) ->
  #    create: (attrs) ->
  #
  #  # Object that properties will be added to the prototype object
  #  # of the User class (all instances of the class will get it)
  #  instanceProperties =
  #    save: ->
  #
  #  class User extends Class
  #    @extend classProperties
  #    @include instanceProperties
  #
  #  # Call class method added with 'extend'
  #  user = User.find(1)
  #
  #  # Call instance method added with 'include'
  #  user = new User
  #  user.save()
  #
  #  or shortcut (do both 'extend' and 'include'):
  #
  #  # Object with properties to be added to the User class
  #  ORM =
  #    find: (id) ->
  #    create: (attrs) ->
  #    extended: ->
  #      @include
  #        save: ->
  #
  #  class User extends Class
  #    @extend ORM
  #
  #============================================================
  */


  moduleKeywords = ['extended', 'included', 'class', 'constructor'];

  Class = (function() {
    /*
      #========================================
      # Class Variables
      #========================================
    */

    function Class() {}

    Class["class"] = 'Class';

    Class.name = null;

    /*
      #========================================
      # Class Methods
      #========================================
    */


    Class.extend = function(object) {
      var key, value, _ref;
      for (key in object) {
        value = object[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((_ref = object.extended) != null) {
        _ref.apply(this);
      }
      return this;
    };

    /*
      # Extends the class with instance properties
    */


    Class.include = function(object) {
      var key, value, _ref;
      for (key in object) {
        value = object[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((_ref = object.included) != null) {
        _ref.apply(this);
      }
      return this;
    };

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    Class.prototype["class"] = function() {
      return this.constructor["class"];
    };

    Class.prototype.initialise = function() {
      this.name = this["class"]().replace(/^.+\./, '');
      log("initialise: " + (this["class"]()));
    };

    return Class;

  })();

  /* --------------------------------------------
       Begin Base.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Project Base
  #
  # Defines the project name and namespace as well as some
  # conveniece methods for logging messages to the console.
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  DEBUG = true;

  STATS = true;

  DOGTAG = 'demo';

  this[DOGTAG] = {};

  /*
  # Logs the provided values in the console.
  # @param {object} values The values to be logged.
  */


  log = function() {
    var values;
    values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (typeof console !== "undefined" && console !== null) {
      console.log.apply(console, ["" + DOGTAG + " »"].concat(__slice.call(values)));
    }
  };

  /*
  # Logs a warning in the console.
  # @param {object} values The values to be logged.
  */


  warn = function() {
    var values;
    values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (typeof console !== "undefined" && console !== null) {
      console.warn.apply(console, ["" + DOGTAG + " »"].concat(__slice.call(values)));
    }
  };

  /*
  # First checks for the provided namespace, and creates it if not found.
  # @param {string} namespace The namespace as a string.
  # @return {object} Reference to the most nested object in the namespace.
  */


  namespace = function(namespace) {
    var space, target, _i, _len, _ref, _ref1;
    target = this[DOGTAG];
    if (typeof namespace === 'string') {
      _ref = namespace.split('.');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        space = _ref[_i];
        target = (_ref1 = target[space]) != null ? _ref1 : target[space] = {};
      }
    }
    return target;
  };

  PROJECT = namespace();

  SHADERS = namespace('shaders');

  DEMOS = namespace('demos');

  /* --------------------------------------------
       Begin Layout.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Layout
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  Layout = (function() {
    /*
      #========================================
      # Constants
      #========================================
    */

    var DELAY;

    DELAY = 200;

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    Layout.prototype.$window = null;

    Layout.prototype.$document = null;

    Layout.prototype.documentHeight = 0;

    Layout.prototype.documentWidth = 0;

    Layout.prototype.windowHeight = 0;

    Layout.prototype.windowWidth = 0;

    Layout.prototype.resized = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    function Layout() {
      this.onWindowResize = __bind(this.onWindowResize, this);

      this.addEventListeners = __bind(this.addEventListeners, this);

      this.dimensions = __bind(this.dimensions, this);

      this.initialise = __bind(this.initialise, this);
      this.$window = $(window);
      this.$document = $(document);
      this.resized = new signals.Signal;
      return;
    }

    Layout.prototype.initialise = function() {
      this.dimensions();
      this.addEventListeners();
    };

    Layout.prototype.dimensions = function() {
      return {
        documentHeight: this.documentHeight = this.$document.height(),
        documentWidth: this.documentWidth = this.$document.width(),
        windowHeight: this.windowHeight = this.$window.height(),
        windowWidth: this.windowWidth = this.$window.width()
      };
    };

    Layout.prototype.addEventListeners = function() {
      this.$window.on('resize', _.debounce(this.onWindowResize, DELAY));
    };

    /*
      #========================================
      # Callbacks
      #========================================
    */


    Layout.prototype.onWindowResize = function(event) {
      var dh, dw, wh, ww;
      ww = this.windowWidth !== this.$window.width();
      wh = this.windowHeight !== this.$window.height();
      dw = this.documentWidth !== this.$document.width();
      dh = this.documentHeight !== this.$document.height();
      if (dh || dw || wh || ww) {
        this.resized.dispatch(this.dimensions());
      }
    };

    return Layout;

  })();

  /* --------------------------------------------
       Begin Codepen.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Codepen utility class for dynamically building pens.
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  Codepen = (function() {
    /*
      #========================================
      # Class Variables
      #========================================
    */

    function Codepen() {}

    Codepen.host = 'http://codepen.io';

    /*
      #========================================
      # Class Methods
      #========================================
    */


    Codepen.buildURL = function(host, user, href, type, height, safe) {
      var query, url;
      query = "?type=" + type + "&height=" + height + "&safe=" + safe;
      url = [host, user, "embed", href + query].join("/");
      return url.replace(/\/\//g, "//");
    };

    Codepen.buildFrame = function($element) {
      var attributes, height, href, key, markup, safe, type, url, user, value;
      user = $element.data('user');
      href = $element.data('href');
      type = $element.data('type');
      safe = $element.data('safe');
      height = $element.data('height');
      url = this.buildURL(this.host, user, href, type, height, safe);
      attributes = {
        id: "cp_embed_" + (href.replace("/", "_")),
        src: url,
        scrolling: "no",
        frameborder: "0",
        height: height,
        allowTransparency: "true",
        "class": "cp_embed_iframe",
        style: "width:100%; border:none; overflow:hidden;"
      };
      markup = "<iframe ";
      for (key in attributes) {
        value = attributes[key];
        markup += "" + key + "=\"" + value + "\" ";
      }
      return markup + ">";
    };

    return Codepen;

  })();

  /* --------------------------------------------
       Begin Utils.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Shader Utilities
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  # @author Zaidin Amiot (Fantasy Interactive)
  #
  #============================================================
  */


  UTILS = " // GLSL\n\n// Constants\nfloat PI = 3.14159265358979323846264;\nfloat PI2 = PI * 2.0;\nfloat PIH = PI * 0.5;\n\n// Blend\nfloat blend(float value, float a, float b) {\n  return clamp((value - a) / (b - a), 0.0, 1.0);\n}\n\n// Normalise\nfloat normalise(float value, float min, float max) {\n  return (value - min) / (max - min);\n}\n\n// Normalise\nfloat interpolate(float value, float a, float b) {\n  return a + (b - a) * value;\n}\n\n// Map\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return interpolate(normalise(value, min1, max1), min2, max2);\n}\n\n// Fog\nfloat fog(float depth, vec3 fog) {\n  return map(blend(depth, fog.x, fog.y), 0.0, 1.0, 1.0, fog.z);\n}\n\n// Project\nvec3 project(float longitude, float latitude, float radius) {\n\n  // Convert degrees to radians.\n  float rx = radians(longitude);\n  float ry = radians(latitude);\n\n  // Cache sin and cos for x and y.\n  float sx = sin(rx);\n  float cx = cos(rx);\n  float sy = sin(ry);\n  float cy = cos(ry);\n\n  // Calculate x, y and z.\n  float x = -radius * cy * cx;\n  float y =  radius * sy;\n  float z =  radius * cy * sx;\n\n  // Return the projected vec3.\n  return vec3(x, y, z);\n}\n\n// Bezier\nvec2 bezierPoint(float index, float size, vec3 factoral, vec2 control, float ratio) {\n\n  vec2 point = vec2(0.0);\n\n  float f = factoral.x / (factoral.y * factoral.z);\n  float p = pow(1.0 - ratio, size - index) * pow(ratio, index);\n\n  point.x = f * p * control.x;\n  point.y = f * p * control.y;\n\n  return point;\n}\n\n// Bezier\nvec2 bezier5v(vec2 points[5], float ratio) {\n\n  // Point to return.\n  vec2 point = vec2(0.0);\n  vec3 factoral = vec3(4.0 * 3.0 * 2.0);\n  float size = 4.0;\n\n  // Factoral calculation:\n  // return 1 if value is 0\n  // factoral = 1\n  // factoral *= i for i in [value...1]\n\n  // Point 0: i = 0\n  factoral.y = 1.0;  // f(i)        = Special case = 1\n  factoral.z = 24.0; // f(size - i) = 4 - 0 = 4 * 3 * 2 * 1 = 24\n  point += bezierPoint(0.0, size, factoral, points[0], ratio);\n\n  // Point 1: i = 1\n  factoral.y = 1.0;  // f(i)        = 1 * 1 = 1\n  factoral.z = 6.0;  // f(size - i) = 4 - 1 = 3 * 2 * 1 = 6\n  point += bezierPoint(1.0, size, factoral, points[1], ratio);\n\n  // Point 2: i = 2\n  factoral.y = 2.0;  // f(i)        = 2 * 1 = 2\n  factoral.z = 2.0;  // f(size - i) = 4 - 2 = 2 * 1 = 2\n  point += bezierPoint(2.0, size, factoral, points[2], ratio);\n\n  // Point 3: i = 3\n  factoral.y = 6.0;  // f(i)        = 3 * 2 * 1 = 6\n  factoral.z = 1.0;  // f(size - i) = 4 - 3 = 1 * 1 = 1\n  point += bezierPoint(3.0, size, factoral, points[3], ratio);\n\n  // Point 4: i = 4\n  factoral.y = 24.0; // f(i)        = 4 * 3 * 2 * 1 = 24\n  factoral.z = 1.0;  // f(size - i) = 4 - 4 = 0 = Special case = 1\n  point += bezierPoint(4.0, size, factoral, points[4], ratio);\n\n  // Return the point.\n  return point;\n}";

  TERRAIN_UTILS = " // GLSL\n\n// Compute position base on phase, amplitude and noise seeds.\nvec3 computePosition(vec3 position, float phase, float amplitude, vec4 noise) {\n  float displace = snoise( (position + noise.xyz * 100.0) / noise.w / 100.0 );\n  return position + vec3(0, 0, 1) * displace * phase * amplitude;\n}\n\n// Compute phase based on time and frequency.\nfloat computePhase(float time, float frequency) {\n  if(time == -1.0){\n    time = 1.0;\n  }\n  return sin( time * frequency );\n}\n\n// Compute the normal of the triangle based on its 3 vertices.\nvec3 computeNormal(vec3 p0, vec3 p1, vec3 p2) {\n  return cross( p1 - p0, p2 - p1 );\n}\n\n// Compute the normal of the segment based on its 2 vertices.\nvec2 computeSegmentNormals(vec2 p0, vec2 p1) {\n  float dx = p1.x - p0.x;\n  float dy = p1.y - p0.y;\n  return normalize( vec2( -dy, dx ) );\n}";

  /* --------------------------------------------
       Begin Wireframe.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Wireframe edge detection fragment shader
  #
  # @author Three.js example file
  #
  #============================================================
  */


  WIREFRAME_EDGE_DETECTION = " // GLSL\n\n/*\n/  Wireframe\n/\n/  Must be declared in vertex shader:\n/  uniform float vLinewidth;\n/  varying float vLinewidth;\n*/\n#extension GL_OES_standard_derivatives : enable\n\nvarying float vLinewidth;\n\n// Position\nfloat edgeFactor( vec3 center ) {\n  vec3 d = fwidth( center );\n  vec3 a3 = smoothstep( vec3( 0.0 ), d * vLinewidth, center );\n  return min( min( a3.x, a3.y ), a3.z );\n}\n\nfloat edgeFactorQuad( vec2 center ) {\n  vec2 d = fwidth( center );\n  vec2 a2 = smoothstep( vec2(0.0), d * vLinewidth, center );\n  return min( a2.x, a2.y );\n}\n\nfloat edgeFactor(vec2 center) {\n  return min( edgeFactorQuad( center ), edgeFactorQuad( 1.0 - center ) );\n}";

  /* --------------------------------------------
       Begin SimplexNoise.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Simplex Noise
  #
  # @author Stefan Gustavson
  #
  #============================================================
  */


  SIMPLEX_NOISE = " // GLSL\nprecision highp float;\n\n/*\n * 2D, 3D and 4D Perlin noise, classic and simplex, in a GLSL fragment shader.\n *\n * Classic noise is implemented by the functions:\n * float noise(vec2 P)\n * float noise(vec3 P)\n * float noise(vec4 P)\n *\n * Simplex noise is implemented by the functions:\n * float snoise(vec2 P)\n * float snoise(vec3 P)\n * float snoise(vec4 P)\n *\n * Author: Stefan Gustavson ITN-LiTH (stegu@itn.liu.se) 2004-12-05\n * Simplex indexing functions by Bill Licea-Kane, ATI\n *\n * You may use, modify and redistribute this code free of charge,\n * provided that the author's names and this notice appear intact.\n */\n\n/*\n * The value of classic 4D noise goes above 1.0 and below -1.0 at some\n * points. Not much and only very sparsely, but it happens. This is a\n * bug from the original software implementation, so I left it untouched.\n */\n\n/*\n * \"permTexture\" is a 256x256 texture that is used for both the permutations\n * and the 2D and 3D gradient lookup. For details, see the main C program.\n * \"gradTexture\" is a 256x256 texture with 4D gradients, similar to\n * \"permTexture\" but with the permutation index in the alpha component\n * replaced by the w component of the 4D gradient.\n * 2D classic noise uses only permTexture.\n * 2D simplex noise uses only permTexture.\n * 3D classic noise uses only permTexture.\n * 3D simplex noise uses only permTexture.\n * 4D classic noise uses permTexture and gradTexture.\n * 4D simplex noise uses permTexture and gradTexture.\n */\nuniform sampler2D permTexture;\nuniform sampler2D gradTexture;\nuniform float time; // Used for texture animation\n\n/*\n * Both 2D and 3D texture coordinates are defined, for testing purposes.\n */\nvarying vec3 vTextureCoord;\n\n/*\n * To create offsets of one texel and one half texel in the\n * texture lookup, we need to know the texture image size.\n */\n#define ONE 0.00390625\n#define ONEHALF 0.001953125\n// The numbers above are 1/256 and 0.5/256, change accordingly\n// if you change the code to use another perm/grad texture size.\n\n/*\n * The 5th degree smooth interpolation function for Perlin \"improved noise\".\n */\nfloat fade(const in float t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise\n}\n\n/*\n * Efficient simplex indexing functions by Bill Licea-Kane, ATI. Thanks!\n * (This was originally implemented as a texture lookup. Nice to avoid that.)\n */\nvoid simplex( const in vec3 P, out vec3 offset1, out vec3 offset2 )\n{\n  vec3 offset0;\n\n  vec2 isX = step( P.yz, P.xx );       // P.x >= P.y ? 1.0 : 0.0; P.x >= P.z ? 1.0 : 0.0;\n  offset0.x = dot( isX, vec2( 1.0 ) ); // Accumulate all P.x >= other channels in offset.x\n  offset0.yz = 1.0 - isX;              // Accumulate all P.x < other channels in offset.yz\n\n  float isY = step( P.z, P.y );        // P.y >= P.z ? 1.0 : 0.0;\n  offset0.y += isY;                    // Accumulate P.y >= P.z in offset.y\n  offset0.z += 1.0 - isY;              // Accumulate P.y < P.z in offset.z\n\n  // offset0 now contains the unique values 0,1,2 in each channel\n  // 2 for the channel greater than other channels\n  // 1 for the channel that is less than one but greater than another\n  // 0 for the channel less than other channels\n  // Equality ties are broken in favor of first x, then y\n  // (z always loses ties)\n\n  offset2 = clamp(   offset0, 0.0, 1.0 ); // offset2 contains 1 in each channel that was 1 or 2\n  offset1 = clamp( --offset0, 0.0, 1.0 ); // offset1 contains 1 in the single channel that was 1\n}\n\nvoid simplex( const in vec4 P, out vec4 offset1, out vec4 offset2, out vec4 offset3 )\n{\n  vec4 offset0;\n\n  vec3 isX = step( P.yzw, P.xxx );     // See comments in 3D simplex function\n  offset0.x = dot( isX, vec3( 1.0 ) );\n  offset0.yzw = 1.0 - isX;\n\n  vec2 isY = step( P.zw, P.yy );\n  offset0.y += dot( isY, vec2( 1.0 ) );\n  offset0.zw += 1.0 - isY;\n\n  float isZ = step( P.w, P.z );\n  offset0.z += isZ;\n  offset0.w += 1.0 - isZ;\n\n  // offset0 now contains the unique values 0,1,2,3 in each channel\n\n  offset3 = clamp(   offset0, 0.0, 1.0 );\n  offset2 = clamp( --offset0, 0.0, 1.0 );\n  offset1 = clamp( --offset0, 0.0, 1.0 );\n}\n\n\n\n/*\n * 2D classic Perlin noise. Fast, but less useful than 3D noise.\n */\nfloat noise(const in vec2 P)\n{\n  vec2 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled and offset for texture lookup\n  vec2 Pf = fract(P);             // Fractional part for interpolation\n\n  // Noise contribution from lower left corner\n  vec2 grad00 = texture2D(permTexture, Pi).rg * 4.0 - 1.0;\n  float n00 = dot(grad00, Pf);\n\n  // Noise contribution from lower right corner\n  vec2 grad10 = texture2D(permTexture, Pi + vec2(ONE, 0.0)).rg * 4.0 - 1.0;\n  float n10 = dot(grad10, Pf - vec2(1.0, 0.0));\n\n  // Noise contribution from upper left corner\n  vec2 grad01 = texture2D(permTexture, Pi + vec2(0.0, ONE)).rg * 4.0 - 1.0;\n  float n01 = dot(grad01, Pf - vec2(0.0, 1.0));\n\n  // Noise contribution from upper right corner\n  vec2 grad11 = texture2D(permTexture, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float n11 = dot(grad11, Pf - vec2(1.0, 1.0));\n\n  // Blend contributions along x\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade(Pf.x));\n\n  // Blend contributions along y\n  float n_xy = mix(n_x.x, n_x.y, fade(Pf.y));\n\n  // We're done, return the final noise value.\n  return n_xy;\n}\n\n\n\n/*\n * 3D classic noise. Slower, but a lot more useful than 2D noise.\n */\nfloat noise(const in vec3 P)\n{\n  vec3 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled so +1 moves one texel\n                                  // and offset 1/2 texel to sample texel centers\n  vec3 Pf = fract(P);             // Fractional part for interpolation\n\n  // Noise contributions from (x=0, y=0), z=0 and z=1\n  float perm00 = texture2D(permTexture, Pi.xy).a ;\n  vec3 grad000 = texture2D(permTexture, vec2(perm00, Pi.z)).rgb * 4.0 - 1.0;\n  float n000 = dot(grad000, Pf);\n  vec3 grad001 = texture2D(permTexture, vec2(perm00, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n001 = dot(grad001, Pf - vec3(0.0, 0.0, 1.0));\n\n  // Noise contributions from (x=0, y=1), z=0 and z=1\n  float perm01 = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a ;\n  vec3 grad010 = texture2D(permTexture, vec2(perm01, Pi.z)).rgb * 4.0 - 1.0;\n  float n010 = dot(grad010, Pf - vec3(0.0, 1.0, 0.0));\n  vec3 grad011 = texture2D(permTexture, vec2(perm01, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n011 = dot(grad011, Pf - vec3(0.0, 1.0, 1.0));\n\n  // Noise contributions from (x=1, y=0), z=0 and z=1\n  float perm10 = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a ;\n  vec3 grad100 = texture2D(permTexture, vec2(perm10, Pi.z)).rgb * 4.0 - 1.0;\n  float n100 = dot(grad100, Pf - vec3(1.0, 0.0, 0.0));\n  vec3 grad101 = texture2D(permTexture, vec2(perm10, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n101 = dot(grad101, Pf - vec3(1.0, 0.0, 1.0));\n\n  // Noise contributions from (x=1, y=1), z=0 and z=1\n  float perm11 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a ;\n  vec3 grad110 = texture2D(permTexture, vec2(perm11, Pi.z)).rgb * 4.0 - 1.0;\n  float n110 = dot(grad110, Pf - vec3(1.0, 1.0, 0.0));\n  vec3 grad111 = texture2D(permTexture, vec2(perm11, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float n111 = dot(grad111, Pf - vec3(1.0, 1.0, 1.0));\n\n  // Blend contributions along x\n  vec4 n_x = mix(vec4(n000, n001, n010, n011), vec4(n100, n101, n110, n111), fade(Pf.x));\n\n  // Blend contributions along y\n  vec2 n_xy = mix(n_x.xy, n_x.zw, fade(Pf.y));\n\n  // Blend contributions along z\n  float n_xyz = mix(n_xy.x, n_xy.y, fade(Pf.z));\n\n  // We're done, return the final noise value.\n  return n_xyz;\n}\n\n\n\n/*\n * 4D classic noise. Slow, but very useful. 4D simplex noise is a lot faster.\n *\n * This function performs 8 texture lookups and 16 dependent texture lookups,\n * 16 dot products, 4 mix operations and a lot of additions and multiplications.\n * Needless to say, it's not super fast. But it's not dead slow either.\n */\nfloat noise(const in vec4 P)\n{\n  vec4 Pi = ONE*floor(P)+ONEHALF; // Integer part, scaled so +1 moves one texel\n                                  // and offset 1/2 texel to sample texel centers\n  vec4 Pf = fract(P);             // Fractional part for interpolation\n\n  // \"n0000\" is the noise contribution from (x=0, y=0, z=0, w=0), and so on\n  float perm00xy = texture2D(permTexture, Pi.xy).a ;\n  float perm00zw = texture2D(permTexture, Pi.zw).a ;\n  vec4 grad0000 = texture2D(gradTexture, vec2(perm00xy, perm00zw)).rgba * 4.0 -1.0;\n  float n0000 = dot(grad0000, Pf);\n\n  float perm01zw = texture2D(permTexture, Pi.zw + vec2(0.0, ONE)).a ;\n  vec4 grad0001 = texture2D(gradTexture, vec2(perm00xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n0001 = dot(grad0001, Pf - vec4(0.0, 0.0, 0.0, 1.0));\n\n  float perm10zw = texture2D(permTexture, Pi.zw + vec2(ONE, 0.0)).a ;\n  vec4 grad0010 = texture2D(gradTexture, vec2(perm00xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n0010 = dot(grad0010, Pf - vec4(0.0, 0.0, 1.0, 0.0));\n\n  float perm11zw = texture2D(permTexture, Pi.zw + vec2(ONE, ONE)).a ;\n  vec4 grad0011 = texture2D(gradTexture, vec2(perm00xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n0011 = dot(grad0011, Pf - vec4(0.0, 0.0, 1.0, 1.0));\n\n  float perm01xy = texture2D(permTexture, Pi.xy + vec2(0.0, ONE)).a ;\n  vec4 grad0100 = texture2D(gradTexture, vec2(perm01xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n0100 = dot(grad0100, Pf - vec4(0.0, 1.0, 0.0, 0.0));\n\n  vec4 grad0101 = texture2D(gradTexture, vec2(perm01xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n0101 = dot(grad0101, Pf - vec4(0.0, 1.0, 0.0, 1.0));\n\n  vec4 grad0110 = texture2D(gradTexture, vec2(perm01xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n0110 = dot(grad0110, Pf - vec4(0.0, 1.0, 1.0, 0.0));\n\n  vec4 grad0111 = texture2D(gradTexture, vec2(perm01xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n0111 = dot(grad0111, Pf - vec4(0.0, 1.0, 1.0, 1.0));\n\n  float perm10xy = texture2D(permTexture, Pi.xy + vec2(ONE, 0.0)).a ;\n  vec4 grad1000 = texture2D(gradTexture, vec2(perm10xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n1000 = dot(grad1000, Pf - vec4(1.0, 0.0, 0.0, 0.0));\n\n  vec4 grad1001 = texture2D(gradTexture, vec2(perm10xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n1001 = dot(grad1001, Pf - vec4(1.0, 0.0, 0.0, 1.0));\n\n  vec4 grad1010 = texture2D(gradTexture, vec2(perm10xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n1010 = dot(grad1010, Pf - vec4(1.0, 0.0, 1.0, 0.0));\n\n  vec4 grad1011 = texture2D(gradTexture, vec2(perm10xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n1011 = dot(grad1011, Pf - vec4(1.0, 0.0, 1.0, 1.0));\n\n  float perm11xy = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a ;\n  vec4 grad1100 = texture2D(gradTexture, vec2(perm11xy, perm00zw)).rgba * 4.0 - 1.0;\n  float n1100 = dot(grad1100, Pf - vec4(1.0, 1.0, 0.0, 0.0));\n\n  vec4 grad1101 = texture2D(gradTexture, vec2(perm11xy, perm01zw)).rgba * 4.0 - 1.0;\n  float n1101 = dot(grad1101, Pf - vec4(1.0, 1.0, 0.0, 1.0));\n\n  vec4 grad1110 = texture2D(gradTexture, vec2(perm11xy, perm10zw)).rgba * 4.0 - 1.0;\n  float n1110 = dot(grad1110, Pf - vec4(1.0, 1.0, 1.0, 0.0));\n\n  vec4 grad1111 = texture2D(gradTexture, vec2(perm11xy, perm11zw)).rgba * 4.0 - 1.0;\n  float n1111 = dot(grad1111, Pf - vec4(1.0, 1.0, 1.0, 1.0));\n\n  // Blend contributions along x\n  float fadex = fade(Pf.x);\n  vec4 n_x0 = mix(vec4(n0000, n0001, n0010, n0011), vec4(n1000, n1001, n1010, n1011), fadex);\n  vec4 n_x1 = mix(vec4(n0100, n0101, n0110, n0111), vec4(n1100, n1101, n1110, n1111), fadex);\n\n  // Blend contributions along y\n  vec4 n_xy = mix(n_x0, n_x1, fade(Pf.y));\n\n  // Blend contributions along z\n  vec2 n_xyz = mix(n_xy.xy, n_xy.zw, fade(Pf.z));\n\n  // Blend contributions along w\n  float n_xyzw = mix(n_xyz.x, n_xyz.y, fade(Pf.w));\n\n  // We're done, return the final noise value.\n  return n_xyzw;\n}\n\n\n\n/*\n * 2D simplex noise. Somewhat slower but much better looking than classic noise.\n */\nfloat snoise(const in vec2 P) {\n\n// Skew and unskew factors are a bit hairy for 2D, so define them as constants\n// This is (sqrt(3.0)-1.0)/2.0\n#define F2 0.366025403784\n// This is (3.0-sqrt(3.0))/6.0\n#define G2 0.211324865405\n\n  // Skew the (x,y) space to determine which cell of 2 simplices we're in\n  float s = (P.x + P.y) * F2;   // Hairy factor for 2D skewing\n  vec2 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y) * G2; // Hairy factor for unskewing\n  vec2 P0 = Pi - t;             // Unskew the cell origin back to (x,y) space\n  Pi = Pi * ONE + ONEHALF;      // Integer part, scaled and offset for texture lookup\n\n  vec2 Pf0 = P - P0; // The x,y distances from the cell origin\n\n  // For the 2D case, the simplex shape is an equilateral triangle.\n  // Find out whether we are above or below the x=y diagonal to\n  // determine which of the two triangles we're in.\n  vec2 o1;\n  if(Pf0.x > Pf0.y) o1 = vec2(1.0, 0.0); // +x, +y traversal order\n  else o1 = vec2(0.0, 1.0);              // +y, +x traversal order\n\n  // Noise contribution from simplex origin\n  vec2 grad0 = texture2D(permTexture, Pi).rg * 4.0 - 1.0;\n  float t0 = 0.5 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from middle corner\n  vec2 Pf1 = Pf0 - o1 + G2;\n  vec2 grad1 = texture2D(permTexture, Pi + o1*ONE).rg * 4.0 - 1.0;\n  float t1 = 0.5 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n\n  // Noise contribution from last corner\n  vec2 Pf2 = Pf0 - vec2(1.0-2.0*G2);\n  vec2 grad2 = texture2D(permTexture, Pi + vec2(ONE, ONE)).rg * 4.0 - 1.0;\n  float t2 = 0.5 - dot(Pf2, Pf2);\n  float n2;\n  if(t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 70.0 * (n0 + n1 + n2);\n}\n\n\n\n/*\n * 3D simplex noise. Comparable in speed to classic noise, better looking.\n */\nfloat snoise(const in vec3 P) {\n\n// The skewing and unskewing factors are much simpler for the 3D case\n#define F3 0.333333333333\n#define G3 0.166666666667\n\n  // Skew the (x,y,z) space to determine which cell of 6 simplices we're in\n  float s = (P.x + P.y + P.z) * F3;    // Factor for 3D skewing\n  vec3 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y + Pi.z) * G3;\n  vec3 P0 = Pi - t;                    // Unskew the cell origin back to (x,y,z) space\n  Pi = Pi * ONE + ONEHALF;             // Integer part, scaled and offset for texture lookup\n\n  vec3 Pf0 = P - P0; // The x,y distances from the cell origin\n\n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n  // To find out which of the six possible tetrahedra we're in, we need to\n  // determine the magnitude ordering of x, y and z components of Pf0.\n  vec3 o1;\n  vec3 o2;\n  simplex(Pf0, o1, o2);\n\n  // Noise contribution from simplex origin\n  float perm0 = texture2D(permTexture, Pi.xy).a;\n  vec3 grad0 = texture2D(permTexture, vec2(perm0, Pi.z)).rgb * 4.0 - 1.0;\n  float t0 = 0.6 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from second corner\n  vec3 Pf1 = Pf0 - o1 + G3;\n  float perm1 = texture2D(permTexture, Pi.xy + o1.xy*ONE).a;\n  vec3 grad1 = texture2D(permTexture, vec2(perm1, Pi.z + o1.z*ONE)).rgb * 4.0 - 1.0;\n  float t1 = 0.6 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n\n  // Noise contribution from third corner\n  vec3 Pf2 = Pf0 - o2 + 2.0 * G3;\n  float perm2 = texture2D(permTexture, Pi.xy + o2.xy*ONE).a;\n  vec3 grad2 = texture2D(permTexture, vec2(perm2, Pi.z + o2.z*ONE)).rgb * 4.0 - 1.0;\n  float t2 = 0.6 - dot(Pf2, Pf2);\n  float n2;\n  if (t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n\n  // Noise contribution from last corner\n  vec3 Pf3 = Pf0 - vec3(1.0-3.0*G3);\n  float perm3 = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n  vec3 grad3 = texture2D(permTexture, vec2(perm3, Pi.z + ONE)).rgb * 4.0 - 1.0;\n  float t3 = 0.6 - dot(Pf3, Pf3);\n  float n3;\n  if(t3 < 0.0) n3 = 0.0;\n  else {\n    t3 *= t3;\n    n3 = t3 * t3 * dot(grad3, Pf3);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 32.0 * (n0 + n1 + n2 + n3);\n}\n\n\n\n/*\n * 4D simplex noise. A lot faster than classic 4D noise, and better looking.\n */\n\nfloat snoise(const in vec4 P) {\n\n// The skewing and unskewing factors are hairy again for the 4D case\n// This is (sqrt(5.0)-1.0)/4.0\n#define F4 0.309016994375\n// This is (5.0-sqrt(5.0))/20.0\n#define G4 0.138196601125\n\n  // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n  float s = (P.x + P.y + P.z + P.w) * F4;     // Factor for 4D skewing\n  vec4 Pi = floor(P + s);\n  float t = (Pi.x + Pi.y + Pi.z + Pi.w) * G4;\n  vec4 P0 = Pi - t;                           // Unskew the cell origin back to (x,y,z,w) space\n  Pi = Pi * ONE + ONEHALF;                    // Integer part, scaled and offset for texture lookup\n\n  vec4 Pf0 = P - P0; // The x,y distances from the cell origin\n\n  // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n  // To find out which of the 24 possible simplices we're in, we need to\n  // determine the magnitude ordering of x, y, z and w components of Pf0.\n  vec4 o1;\n  vec4 o2;\n  vec4 o3;\n  simplex(Pf0, o1, o2, o3);\n\n  // Noise contribution from simplex origin\n  float perm0xy = texture2D(permTexture, Pi.xy).a;\n  float perm0zw = texture2D(permTexture, Pi.zw).a;\n  vec4 grad0 = texture2D(gradTexture, vec2(perm0xy, perm0zw)).rgba * 4.0 - 1.0;\n  float t0 = 0.6 - dot(Pf0, Pf0);\n  float n0;\n  if (t0 < 0.0) n0 = 0.0;\n  else {\n    t0 *= t0;\n    n0 = t0 * t0 * dot(grad0, Pf0);\n  }\n\n  // Noise contribution from second corner\n  vec4 Pf1 = Pf0 - o1 + G4;\n  o1 = o1 * ONE;\n  float perm1xy = texture2D(permTexture, Pi.xy + o1.xy).a;\n  float perm1zw = texture2D(permTexture, Pi.zw + o1.zw).a;\n  vec4 grad1 = texture2D(gradTexture, vec2(perm1xy, perm1zw)).rgba * 4.0 - 1.0;\n  float t1 = 0.6 - dot(Pf1, Pf1);\n  float n1;\n  if (t1 < 0.0) n1 = 0.0;\n  else {\n    t1 *= t1;\n    n1 = t1 * t1 * dot(grad1, Pf1);\n  }\n\n  // Noise contribution from third corner\n  vec4 Pf2 = Pf0 - o2 + 2.0 * G4;\n  o2 = o2 * ONE;\n  float perm2xy = texture2D(permTexture, Pi.xy + o2.xy).a;\n  float perm2zw = texture2D(permTexture, Pi.zw + o2.zw).a;\n  vec4 grad2 = texture2D(gradTexture, vec2(perm2xy, perm2zw)).rgba * 4.0 - 1.0;\n  float t2 = 0.6 - dot(Pf2, Pf2);\n  float n2;\n  if (t2 < 0.0) n2 = 0.0;\n  else {\n    t2 *= t2;\n    n2 = t2 * t2 * dot(grad2, Pf2);\n  }\n\n  // Noise contribution from fourth corner\n  vec4 Pf3 = Pf0 - o3 + 3.0 * G4;\n  o3 = o3 * ONE;\n  float perm3xy = texture2D(permTexture, Pi.xy + o3.xy).a;\n  float perm3zw = texture2D(permTexture, Pi.zw + o3.zw).a;\n  vec4 grad3 = texture2D(gradTexture, vec2(perm3xy, perm3zw)).rgba * 4.0 - 1.0;\n  float t3 = 0.6 - dot(Pf3, Pf3);\n  float n3;\n  if (t3 < 0.0) n3 = 0.0;\n  else {\n    t3 *= t3;\n    n3 = t3 * t3 * dot(grad3, Pf3);\n  }\n\n  // Noise contribution from last corner\n  vec4 Pf4 = Pf0 - vec4(1.0-4.0*G4);\n  float perm4xy = texture2D(permTexture, Pi.xy + vec2(ONE, ONE)).a;\n  float perm4zw = texture2D(permTexture, Pi.zw + vec2(ONE, ONE)).a;\n  vec4 grad4 = texture2D(gradTexture, vec2(perm4xy, perm4zw)).rgba * 4.0 - 1.0;\n  float t4 = 0.6 - dot(Pf4, Pf4);\n  float n4;\n  if(t4 < 0.0) n4 = 0.0;\n  else {\n    t4 *= t4;\n    n4 = t4 * t4 * dot(grad4, Pf4);\n  }\n\n  // Sum up and scale the result to cover the range [-1,1]\n  return 27.0 * (n0 + n1 + n2 + n3 + n4);\n}\n\n\n\n// Ridged multifractal\n// See \"Texturing & Modeling, A Procedural Approach\", Chapter 12\nfloat ridge(float h, float offset)\n{\n    h = abs(h);\n    h = offset - h;\n    h = h * h;\n    return h;\n}\n\nfloat ridgedmf(vec4 p, float lacunarity, float gain, float offset, int octaves)\n{\n  float sum = 0.0;\n  float freq = 1.0, amp = 0.5;\n  float prev = 1.0;\n  for(int i=0; i<3; i++) {\n    float noise = snoise(p*freq);\n    float n = ridge(noise, offset);\n    sum += n*amp*prev;\n    prev = n;\n    freq *= lacunarity;\n    amp *= gain;\n  }\n  return sum;\n}\n\nfloat ridgedmfDefault(vec4 p, int octaves)\n{\n  return ridgedmf(p, 2.0, 0.5, 1.0, octaves);\n}\n\nfloat bias(float a, float b)\n{\n  return pow(a, log(b) / log(0.5));\n}";

  /* --------------------------------------------
       Begin Shader.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Abstract Shader
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  #
  #============================================================
  */


  SHADERS.Shader = (function(_super) {
    var ATTRIBUTES, UNIFORMS;

    __extends(Shader, _super);

    /*
      #========================================
      # Attributes
      #========================================
    */


    ATTRIBUTES = null;

    /*
      #========================================
      # Uniforms
      #========================================
    */


    UNIFORMS = null;

    /*
      #========================================
      # Vertex Shader
      #========================================
    */


    Shader.VERTEX_SHADER = "\n// Attributes\n// attribute vec3 aColor;\n\n// Uniforms\n// uniform float uScale;\n\n// Varyings\n// varying vec3 vColor;\n\n// Main\nvoid main() {\n\n  // vColor = aColor;\n\n  // Set gl_Position\n  gl_Position = projectionMatrix *\n                modelViewMatrix *\n                vec4(position, 1.0);\n}";

    /*
      #========================================
      # Fragment Shader
      #========================================
    */


    Shader.FRAGMENT_SHADER = "\n// Uniforms\n// uniform float uScale;\n\n// Varyings\n// varying vec3 vColor;\n\n// Main\nvoid main() {\n\n  // Set gl_FragColor\n  gl_FragColor = vec4(0.8, 0.0, 0.2, 1.0);\n}";

    /*
      #========================================
      # Class Methods
      #========================================
    */


    Shader.merge = function(source, object) {
      var copy, key, name, property, value;
      source = source || {};
      for (name in object) {
        property = object[name];
        if (source[name] == null) {
          source[name] = {};
          for (key in property) {
            value = property[key];
            copy = value;
            if (_.isArray(value)) {
              copy = value.concat();
            } else if (_.isFunction(value.clone)) {
              copy = value.clone();
            } else if (value instanceof THREE.Matrix3) {
              copy = new THREE.Matrix3;
              copy.elements = value.elements.concat();
            }
            source[name][key] = copy;
          }
        }
      }
      return source;
    };

    Shader.clone = function(object) {
      var clone, copy, key, name, property, value;
      clone = {};
      for (name in object) {
        property = object[name];
        clone[name] = {};
        for (key in property) {
          value = property[key];
          copy = value;
          if (_.isArray(value)) {
            copy = value.concat();
          } else if (_.isFunction(value.clone)) {
            copy = value.clone();
          } else if (value instanceof THREE.Matrix3) {
            copy = new THREE.Matrix3;
            copy.elements = value.elements.concat();
          }
          clone[name][key] = copy;
        }
      }
      return clone;
    };

    Shader.cloneAttributes = function() {
      return this.clone(this.ATTRIBUTES);
    };

    Shader.cloneUniforms = function() {
      return this.clone(this.UNIFORMS);
    };

    Shader.cloneVertexShader = function() {
      return this.VERTEX_SHADER;
    };

    Shader.cloneFragmentShader = function() {
      return this.FRAGMENT_SHADER;
    };

    /*
      #========================================
      # Constructor
      #========================================
    */


    function Shader(parameters) {
      var key, material, value;
      parameters = parameters || {};
      parameters.vertexShader = this.constructor.VERTEX_SHADER;
      parameters.fragmentShader = this.constructor.FRAGMENT_SHADER;
      parameters.uniforms = this.constructor.merge(parameters.uniforms, this.constructor.cloneUniforms());
      parameters.attributes = this.constructor.merge(parameters.attributes, this.constructor.cloneAttributes());
      material = new THREE.ShaderMaterial(parameters);
      if (!(function() {
        var _results;
        _results = [];
        for (key in parameters) {
          value = parameters[key];
          _results.push(material[key] != null);
        }
        return _results;
      })()) {
        material[key] = value;
      }
      return material;
    }

    return Shader;

  })(Class);

  /* --------------------------------------------
       Begin Dust.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Dust Shader
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  #
  #============================================================
  */


  SHADERS.Dust = (function(_super) {

    __extends(Dust, _super);

    /*
      #========================================
      # Attributes
      #========================================
    */


    function Dust() {
      return Dust.__super__.constructor.apply(this, arguments);
    }

    Dust.ATTRIBUTES = {
      aScale: {
        type: 'f',
        value: []
      },
      aStep: {
        type: 'v4',
        value: []
      }
    };

    /*
      #========================================
      # Uniforms
      #========================================
    */


    Dust.UNIFORMS = {
      uAlpha: {
        type: 'f',
        value: 1
      },
      uTime: {
        type: 'f',
        value: 0
      },
      uSpeed: {
        type: 'f',
        value: 0
      },
      uPhase: {
        type: 'f',
        value: 0
      },
      uScale: {
        type: 'f',
        value: 1
      },
      uSize: {
        type: 'f',
        value: 1
      },
      uOpacity: {
        type: 'v2',
        value: new THREE.Vector2
      },
      uRadii: {
        type: 'v2',
        value: new THREE.Vector2
      },
      uMap: {
        type: 't',
        value: new THREE.Texture
      },
      uColor: {
        type: 'v3',
        value: new THREE.Vector3(1, 1, 1)
      }
    };

    /*
      #========================================
      # Vertex Shader
      #========================================
    */


    Dust.VERTEX_SHADER = " // GLSL\n\n// Includes\n" + UTILS + "\n\n// Attributes\nattribute float aScale;\nattribute vec4 aStep;\n\n// Uniforms\nuniform sampler2D uMap;\nuniform float uAlpha;\nuniform float uTime;\nuniform float uSpeed;\nuniform float uPhase;\nuniform float uScale;\nuniform float uSize;\nuniform vec2 uOpacity;\nuniform vec3 uColor;\nuniform vec2 uRadii;\n\n// Varyings\nvarying vec4 vColor;\n\n// Main\nvoid main() {\n\n  // Calculate the position of the vertex.\n  float speed = uTime * uSpeed;\n  float longitude = position.x + speed * aStep.x;\n  float latitude = position.y + speed * aStep.y;\n  float radius = map(position.z, 0.0, 1.0, uRadii.x, uRadii.y);\n\n  // Calculate vertex and model view position.\n  vec3 vertexPosition = project(longitude, latitude, radius);\n  // vec3 vertexPosition = project(longitude, latitude, 100.0);\n  vec4 modelViewPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n\n  // Set gl_PointSize\n  gl_PointSize = uSize * (uScale / length(modelViewPosition.xyz)) * aScale;\n\n  // Set gl_Position\n  gl_Position = projectionMatrix * modelViewPosition;\n\n  // Color\n  float phase = sin(uTime * uPhase * aStep.w);\n  vColor = vec4(uColor, map(phase, -1.0, 1.0, uOpacity.x, uOpacity.y));\n  vColor.w *= uAlpha;\n}";

    /*
      #========================================
      # Fragment Shader
      #========================================
    */


    Dust.FRAGMENT_SHADER = " // GLSL\n\n// Uniforms\nuniform sampler2D uMap;\n\n// Varyings\nvarying vec4 vColor;\n\n// Main\nvoid main() {\n\n  // Map.\n  vec4 map = texture2D(uMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n\n  // Set gl_FragColor\n  gl_FragColor = vColor * map;\n}";

    return Dust;

  })(SHADERS.Shader);

  /* --------------------------------------------
       Begin Noise.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Noise Shader
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  #
  #============================================================
  */


  SHADERS.Noise = (function(_super) {

    __extends(Noise, _super);

    /*
      #========================================
      # Attributes
      #========================================
    */


    /*
      #========================================
      # Uniforms
      #========================================
    */


    function Noise() {
      return Noise.__super__.constructor.apply(this, arguments);
    }

    Noise.UNIFORMS = {
      uSize: {
        type: 'v3',
        value: new THREE.Vector3(0, 0, 0)
      },
      uRange: {
        type: 'v2',
        value: new THREE.Vector2(0, 1)
      },
      uDisplacement: {
        type: 'f',
        value: 0
      },
      uFrequency: {
        type: 'f',
        value: 0
      },
      uTime: {
        type: 'f',
        value: 1
      },
      uColor1: {
        type: 'v4',
        value: new THREE.Vector4(1, 1, 1, 1)
      },
      uColor2: {
        type: 'v4',
        value: new THREE.Vector4(1, 1, 1, 1)
      },
      uNoise: {
        type: 'v4',
        value: new THREE.Vector4(0, 0, 0, 0)
      }
    };

    /*
      #========================================
      # Vertex Shader
      #========================================
    */


    Noise.VERTEX_SHADER = " // GLSL\n\n// Includes\n" + SIMPLEX_NOISE + "\n" + UTILS + "\n\n// Uniforms\nuniform vec3 uSize;\nuniform vec2 uRange;\nuniform float uTime;\nuniform float uFrequency;\nuniform float uDisplacement;\nuniform vec4 uColor1;\nuniform vec4 uColor2;\nuniform vec4 uNoise;\n\n// Varyings\nvarying vec4 vColor;\n\n// Surface\nfloat surface(vec3 coordinate) {\n  float noise = 0.0;\n  noise += uNoise.x * snoise(coordinate * 1.0);\n  noise += uNoise.y * snoise(coordinate * 2.0);\n  noise += uNoise.z * snoise(coordinate * 4.0);\n  noise += uNoise.w * snoise(coordinate * 8.0);\n  return noise;\n}\n\n// Main\nvoid main() {\n\n  // Calculate the displacement of the vertex.\n  float noise = surface(vec3(uv, uTime * uFrequency));\n  float displacement = map(noise, uRange.x, uRange.y, 0.0, 1.0);\n  float range = uSize.y * uDisplacement * displacement;\n  float offset = uSize.y * -0.5;\n\n  // Calculate vertex position.\n  vec3 vertexPosition = vec3(position.x * uSize.x, range + offset, position.y * uSize.z);\n  vec4 modelViewPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n\n  // Set gl_Position\n  gl_Position = projectionMatrix * modelViewPosition;\n\n  // Color\n  vColor = mix(uColor1, uColor2, (vertexPosition.y - offset) / uSize.y);\n}";

    /*
      #========================================
      # Fragment Shader
      #========================================
    */


    Noise.FRAGMENT_SHADER = " // GLSL\n\n// Varyings\nvarying vec4 vColor;\n\n// Main\nvoid main() {\n\n  // Set gl_FragColor\n  gl_FragColor = vColor;\n}";

    return Noise;

  })(SHADERS.Shader);

  /* --------------------------------------------
       Begin Heatmap.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Heatmap Shader
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  #
  #============================================================
  */


  SHADERS.Heatmap = (function(_super) {

    __extends(Heatmap, _super);

    /*
      #========================================
      # Attributes
      #========================================
    */


    function Heatmap() {
      return Heatmap.__super__.constructor.apply(this, arguments);
    }

    Heatmap.ATTRIBUTES = {
      aHue: {
        type: 'v3',
        value: []
      },
      aColor: {
        type: 'v4',
        value: []
      },
      aNormal: {
        type: 'v3',
        value: []
      },
      aType: {
        type: 'f',
        value: []
      }
    };

    /*
      #========================================
      # Uniforms
      #========================================
    */


    Heatmap.UNIFORMS = {
      uMap: {
        type: 't',
        value: new THREE.Texture
      },
      uRadii: {
        type: 'v2',
        value: new THREE.Vector2(0, 1)
      },
      uDisplacement: {
        type: 'f',
        value: 0
      },
      uFrequency: {
        type: 'f',
        value: 0
      },
      uTime: {
        type: 'f',
        value: 1
      },
      uScale: {
        type: 'f',
        value: 1
      },
      uSize: {
        type: 'f',
        value: 1
      },
      uAlpha: {
        type: 'v3',
        value: new THREE.Vector3(1, 1, 1)
      },
      uNoise: {
        type: 'v4',
        value: new THREE.Vector4(0, 0, 0, 0)
      }
    };

    /*
      #========================================
      # Vertex Shader
      #========================================
    */


    Heatmap.VERTEX_SHADER = " // GLSL\n\n// Includes\n" + UTILS + "\n\n// Attributes\nattribute vec3 aHue;\nattribute vec4 aColor;\nattribute vec3 aNormal;\nattribute float aType;\n\n// Uniforms\nuniform sampler2D uMap;\nuniform vec2 uRadii;\nuniform float uTime;\nuniform float uSize;\nuniform float uScale;\nuniform float uFrequency;\nuniform float uDisplacement;\nuniform vec3 uAlpha;\n\n// Varyings\nvarying float vType;\nvarying vec4 vColor;\n\n// Main\nvoid main() {\n\n  // Calculate length.\n  float radius = uRadii.x;\n  float delta = uRadii.y - uRadii.x;\n  float power = 1.0 - aHue.x * 1.5;\n  float displacement = power * uDisplacement;\n  if (aType != 1.0) radius += delta * displacement;\n\n  // Calculate vertex position.\n  vec3 vertexPosition = aNormal * radius;\n\n  // Set the model view position.\n  vec4 modelViewPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n\n  // Set gl_PointSize\n  gl_PointSize = uSize * (uScale / length(modelViewPosition.xyz));\n\n  // Set gl_Position\n  gl_Position = projectionMatrix * modelViewPosition;\n\n  // Type\n  vType = aType;\n\n  // Color\n  vColor = aColor;\n  if (aType == 0.0) vColor.w = uAlpha.x * (1.0 - uDisplacement);\n  if (aType == 1.0) vColor.w = uAlpha.y * uDisplacement;\n  if (aType == 2.0) vColor.w = uAlpha.z * uDisplacement;\n}";

    /*
      #========================================
      # Fragment Shader
      #========================================
    */


    Heatmap.FRAGMENT_SHADER = " // GLSL\n\n// Uniforms\nuniform sampler2D uMap;\n\n// Varyings\nvarying float vType;\nvarying vec4 vColor;\n\n// Main\nvoid main() {\n\n  // Set gl_FragColor\n  gl_FragColor = vColor;\n  if (vType == 0.0) gl_FragColor *= texture2D(uMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n}";

    return Heatmap;

  })(SHADERS.Shader);

  /* --------------------------------------------
       Begin Projection.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Particles Shader
  #
  # @author Matthew Wagerfield (Fantasy Interactive)
  #
  #============================================================
  */


  SHADERS.Projection = (function(_super) {

    __extends(Projection, _super);

    /*
      #========================================
      # Attributes
      #========================================
    */


    function Projection() {
      return Projection.__super__.constructor.apply(this, arguments);
    }

    Projection.ATTRIBUTES = {
      aPosition: {
        type: 'v3',
        value: []
      },
      aRange: {
        type: 'v2',
        value: []
      },
      aStep: {
        type: 'f',
        value: []
      }
    };

    /*
      #========================================
      # Uniforms
      #========================================
    */


    Projection.UNIFORMS = {
      uMap: {
        type: 't',
        value: new THREE.Texture
      },
      uScatter: {
        type: 'f',
        value: 1
      },
      uPhase: {
        type: 'f',
        value: 1
      },
      uPulse: {
        type: 'f',
        value: 1
      },
      uTime: {
        type: 'f',
        value: 1
      },
      uCylinderRatio: {
        type: 'f',
        value: 0
      },
      uSphereRatio: {
        type: 'f',
        value: 0
      },
      uScale: {
        type: 'f',
        value: 1
      },
      uRadius: {
        type: 'f',
        value: 1
      },
      uOffset: {
        type: 'f',
        value: 1
      },
      uSize: {
        type: 'f',
        value: 1
      },
      uDisplacement: {
        type: 'f',
        value: 0
      },
      uColor1: {
        type: 'v4',
        value: new THREE.Vector4(1, 1, 1, 1)
      },
      uColor2: {
        type: 'v4',
        value: new THREE.Vector4(1, 1, 1, 1)
      }
    };

    /*
      #========================================
      # Vertex Shader
      #========================================
    */


    Projection.VERTEX_SHADER = " // GLSL\n\n// Includes\n" + UTILS + "\n\n// Attributes\nattribute vec3 aPosition;\nattribute vec3 aRange;\nattribute float aStep;\n\n// Uniforms\nuniform float uSphereRatio;\nuniform float uCylinderRatio;\nuniform float uDisplacement;\nuniform float uScatter;\nuniform float uPulse;\nuniform float uTime;\nuniform sampler2D uMap;\nuniform float uRadius;\nuniform float uOffset;\nuniform float uScale;\nuniform float uSize;\nuniform vec4 uColor1;\nuniform vec4 uColor2;\n\n// Varyings\nvarying vec4 vColor;\n\n// Main\nvoid main() {\n\n  // Calculate pulse.\n  float sine = sin(uTime * 2.5 - aPosition.y * 7.5);\n  float pulse = map(sine, -1.0, 1.0, 0.0, 1.0);\n\n  // Calculate displacement.\n  float displacement = uDisplacement;\n  if (uPulse == 1.0) displacement *= pulse;\n\n  // Calculate radius.\n  float offset = aPosition.z * uOffset * displacement;\n  float radius = uRadius + offset;\n\n  // Calculate longitude and latitude.\n  float longitude = aPosition.x * 360.0 - 90.0;\n  float latitude  = aPosition.y * 180.0 + 90.0;\n\n  // Calculate plane position.\n  vec3 planePosition;\n  planePosition.x = aPosition.x * uRadius * 4.0 - uRadius * 2.0;\n  planePosition.y = aPosition.y * uRadius * 2.0 + uRadius * 1.0;\n  planePosition.z = offset;\n\n  // Calculate cylinder position.\n  vec3 cylinderPosition = planePosition;\n  cylinderPosition.x = sin(aPosition.x * PI2) * radius * -1.0;\n  cylinderPosition.z = cos(aPosition.x * PI2) * radius * -1.0;\n\n  // Calculate sphere position.\n  vec3 spherePosition = project(longitude, latitude, radius);\n\n  // Derive the vertex position.\n  vec3 mix1 = mix(planePosition, cylinderPosition, uCylinderRatio);\n  vec3 mix2 = mix(mix1, spherePosition, uSphereRatio);\n  vec4 modelViewPosition = modelViewMatrix * vec4(mix2, 1.0);\n\n  // Set gl_PointSize\n  gl_PointSize = uSize * (uScale / length(modelViewPosition.xyz));\n\n  // Set gl_Position\n  gl_Position = projectionMatrix * modelViewPosition;\n\n  // Color\n  vColor = mix(uColor1, uColor2, aPosition.z * displacement);\n}";

    /*
      #========================================
      # Fragment Shader
      #========================================
    */


    Projection.FRAGMENT_SHADER = " // GLSL\n\n// Uniforms\nuniform sampler2D uMap;\n\n// Varyings\nvarying vec4 vColor;\n\n// Main\nvoid main() {\n\n  // Set gl_FragColor\n  gl_FragColor = vColor;\n  gl_FragColor *= texture2D(uMap, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n}";

    return Projection;

  })(SHADERS.Shader);

  /* --------------------------------------------
       Begin Dust.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Dust
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  DEMOS.Dust = (function(_super) {

    __extends(Dust, _super);

    /*
      #========================================
      # Class Variables
      #========================================
    */


    function Dust() {
      this.resize = __bind(this.resize, this);

      this.update = __bind(this.update, this);

      this.updateUniforms = __bind(this.updateUniforms, this);

      this.addDust = __bind(this.addDust, this);

      this.setProperties = __bind(this.setProperties, this);

      this.initialise = __bind(this.initialise, this);
      return Dust.__super__.constructor.apply(this, arguments);
    }

    Dust["class"] = 'DEMOS.Dust';

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    Dust.prototype.innerRadius = null;

    Dust.prototype.outerRadius = null;

    Dust.prototype.length = null;

    Dust.prototype.height = null;

    Dust.prototype.width = null;

    Dust.prototype.count = null;

    Dust.prototype.attributes = null;

    Dust.prototype.uniforms = null;

    Dust.prototype.geometry = null;

    Dust.prototype.material = null;

    Dust.prototype.system = null;

    Dust.prototype.map = null;

    Dust.prototype.innerRatio = null;

    Dust.prototype.outerRatio = null;

    Dust.prototype.minOpacity = null;

    Dust.prototype.maxOpacity = null;

    Dust.prototype.height = null;

    Dust.prototype.width = null;

    Dust.prototype.color = null;

    Dust.prototype.size = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    Dust.prototype.initialise = function(innerRadius, outerRadius, count, width, height) {
      this.innerRadius = innerRadius;
      this.outerRadius = outerRadius;
      this.count = count;
      this.width = width;
      this.height = height;
      this.length = this.outerRadius - this.innerRadius;
      this.setProperties();
      this.addDust();
    };

    Dust.prototype.setProperties = function() {
      this.innerRatio = 0.2;
      this.outerRatio = 0.8;
      this.speed = 2.5;
      this.phase = 4.0;
      this.color = '#BBDDFF';
      this.minOpacity = 0.2;
      this.maxOpacity = 0.6;
      this.size = 4.5;
    };

    Dust.prototype.addDust = function() {
      var index, scale, step, vertex, _i, _ref;
      this.map = THREE.ImageUtils.loadTexture('/assets/graphics/particle.png');
      this.attributes = SHADERS.Dust.cloneAttributes();
      this.uniforms = SHADERS.Dust.cloneUniforms();
      this.uniforms.uMap.value = this.map;
      this.geometry = new THREE.Geometry;
      this.material = new SHADERS.Dust({
        blending: THREE.AdditiveBlending,
        attributes: this.attributes,
        uniforms: this.uniforms,
        transparent: true,
        depthWrite: false,
        depthTest: true
      });
      for (index = _i = 0, _ref = this.count; 0 <= _ref ? _i < _ref : _i > _ref; index = 0 <= _ref ? ++_i : --_i) {
        vertex = new THREE.Vector3;
        vertex.x = Math.randomInRange(0, 360);
        vertex.y = Math.randomInRange(-90, 90);
        vertex.z = Math.randomInRange(0.0, 1.0);
        this.geometry.vertices.push(vertex);
        step = new THREE.Vector4;
        step.x = Math.randomInRange(-1.0, 1.0);
        step.y = Math.randomInRange(-1.0, 1.0);
        step.z = Math.randomInRange(-1.0, 1.0);
        step.w = Math.randomInRange(0.5, 1.0);
        scale = Math.randomInRange(0.5, 1.0);
        this.attributes.aScale.value.push(scale);
        this.attributes.aStep.value.push(step);
      }
      this.system = new THREE.ParticleSystem(this.geometry, this.material);
      this.add(this.system);
      this.updateUniforms();
    };

    Dust.prototype.updateUniforms = function() {
      if (this.uniforms != null) {
        this.uniforms.uRadii.value.x = this.innerRadius + this.innerRatio * this.length;
        this.uniforms.uRadii.value.y = this.innerRadius + this.outerRatio * this.length;
        this.uniforms.uColor.value = Color.vector3(this.color);
        this.uniforms.uOpacity.value.x = this.minOpacity;
        this.uniforms.uOpacity.value.y = this.maxOpacity;
        this.uniforms.uScale.value = this.height / 2;
        this.uniforms.uSpeed.value = this.speed;
        this.uniforms.uPhase.value = this.phase;
        this.uniforms.uSize.value = this.size;
      }
    };

    Dust.prototype.update = function(delta, time) {
      if (this.uniforms != null) {
        this.uniforms.uTime.value = time;
      }
      if (this.system != null) {
        this.system.rotation.y += delta * 0.1;
      }
    };

    Dust.prototype.resize = function(width, height) {
      this.width = width;
      this.height = height;
      this.updateUniforms();
    };

    return Dust;

  })(THREE.Object3D);

  /* --------------------------------------------
       Begin Scene.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Abstract Demo Class
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  DEMOS.Scene = (function(_super) {

    __extends(Scene, _super);

    /*
      #========================================
      # Constants
      #========================================
    */


    /*
      #========================================
      # Class Variables
      #========================================
    */


    Scene["class"] = 'DEMOS.Scene';

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    Scene.prototype.$hotspot = null;

    Scene.prototype.$vignetting = null;

    Scene.prototype.$scanlines = null;

    Scene.prototype.$lensflare = null;

    Scene.prototype.renderer = null;

    Scene.prototype.controls = null;

    Scene.prototype.element = null;

    Scene.prototype.camera = null;

    Scene.prototype.origin = null;

    Scene.prototype.scene = null;

    Scene.prototype.aspect = null;

    Scene.prototype.height = null;

    Scene.prototype.width = null;

    Scene.prototype.near = null;

    Scene.prototype.far = null;

    Scene.prototype.fov = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    function Scene(width, height, fov, near, far) {
      this.width = width;
      this.height = height;
      this.fov = fov != null ? fov : 60;
      this.near = near != null ? near : 1;
      this.far = far != null ? far : 1e6;
      this.onMouseUp = __bind(this.onMouseUp, this);

      this.onMouseDown = __bind(this.onMouseDown, this);

      this.resize = __bind(this.resize, this);

      this.update = __bind(this.update, this);

      this.remove = __bind(this.remove, this);

      this.add = __bind(this.add, this);

      this.addEventListeners = __bind(this.addEventListeners, this);

      this.aspect = this.width / this.height;
      this.origin = new THREE.Object3D;
      this.scene = new THREE.Scene;
      this.scene.add(this.origin);
      this.camera = new THREE.PerspectiveCamera(this.fov, this.aspect, this.near, this.far);
      this.camera.position.z = 500;
      this.renderer = new THREE.WebGLRenderer;
      this.renderer.setSize(this.width, this.height);
      this.element = this.renderer.domElement;
      this.$element = $(this.renderer.domElement).addClass('scene');
      this.$vignetting = $('<div>').addClass('vignetting');
      this.$scanlines = $('<div>').addClass('scanlines');
      this.$lensflare = $('<div>').addClass('lensflare');
      this.controls = new TrackballControls(this.origin, this.element);
      this.addEventListeners();
      return;
    }

    Scene.prototype.addEventListeners = function() {
      this.$element.on('mousedown', this.onMouseDown);
      this.$element.on('mouseup', this.onMouseUp);
    };

    Scene.prototype.add = function(object) {
      this.origin.add(object);
    };

    Scene.prototype.remove = function(object) {
      this.origin.remove(object);
    };

    Scene.prototype.update = function(delta, time) {
      var _ref, _ref1;
      if ((_ref = this.controls) != null) {
        _ref.update();
      }
      if ((_ref1 = this.renderer) != null) {
        _ref1.render(this.scene, this.camera);
      }
    };

    Scene.prototype.resize = function(width, height) {
      var _ref, _ref1, _ref2;
      this.width = width;
      this.height = height;
      this.aspect = this.width / this.height;
      if ((_ref = this.camera) != null) {
        _ref.aspect = this.aspect;
      }
      if ((_ref1 = this.camera) != null) {
        _ref1.updateProjectionMatrix();
      }
      if ((_ref2 = this.renderer) != null) {
        _ref2.setSize(this.width, this.height);
      }
    };

    /*
      #========================================
      # Callbacks
      #========================================
    */


    Scene.prototype.onMouseDown = function(event) {
      this.$element.addClass('grabbing');
    };

    Scene.prototype.onMouseUp = function(event) {
      this.$element.removeClass('grabbing');
    };

    return Scene;

  })(Class);

  /* --------------------------------------------
       Begin ImageBuffer.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Image Buffer
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  DEMOS.ImageBuffer = (function(_super) {

    __extends(ImageBuffer, _super);

    /*
      #========================================
      # Constants
      #========================================
    */


    /*
      #========================================
      # Class Variables
      #========================================
    */


    ImageBuffer["class"] = 'DEMOS.ImageBuffer';

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    ImageBuffer.prototype.$image = null;

    ImageBuffer.prototype.$canvas = null;

    ImageBuffer.prototype.formattedData = null;

    ImageBuffer.prototype.imageData = null;

    ImageBuffer.prototype.rendered = null;

    ImageBuffer.prototype.context = null;

    ImageBuffer.prototype.height = null;

    ImageBuffer.prototype.width = null;

    ImageBuffer.prototype.image = null;

    ImageBuffer.prototype.data = null;

    ImageBuffer.prototype.url = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    function ImageBuffer(url) {
      this.url = url;
      this.onImageLoad = __bind(this.onImageLoad, this);

      this.load = __bind(this.load, this);

      this.rendered = new signals.Signal;
      this.$canvas = $('<canvas>').addClass('buffer');
      this.context = this.$canvas[0].getContext('2d');
      this.image = new Image;
      this.$image = $(this.image);
      this.$image.load(this.onImageLoad);
      this.load(this.url);
      return;
    }

    ImageBuffer.prototype.load = function(url) {
      this.url = url;
      this.$image.attr('src', this.url);
    };

    /*
      #========================================
      # Callbacks
      #========================================
    */


    ImageBuffer.prototype.onImageLoad = function(event) {
      this.width = event.target.width;
      this.height = event.target.height;
      this.$canvas.attr({
        width: this.width,
        height: this.height
      });
      this.context.clearRect(0, 0, this.width, this.height);
      this.context.drawImage(this.image, 0, 0);
      this.imageData = this.context.getImageData(0, 0, this.width, this.height);
      this.formattedData = Canvas.format(this.imageData, true, true);
      this.rendered.dispatch(this.width, this.height, this.formattedData);
    };

    return ImageBuffer;

  })(Class);

  /* --------------------------------------------
       Begin Demo.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Abstract Demo Class
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  DEMOS.Demo = (function(_super) {

    __extends(Demo, _super);

    /*
      #========================================
      # Constants
      #========================================
    */


    /*
      #========================================
      # Class Variables
      #========================================
    */


    Demo["class"] = 'DEMOS.Demo';

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    Demo.prototype.$container = null;

    Demo.prototype.height = null;

    Demo.prototype.width = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    function Demo($container) {
      this.$container = $container;
      this.resize = __bind(this.resize, this);

      this.update = __bind(this.update, this);

      this.initialise = __bind(this.initialise, this);

      return;
    }

    Demo.prototype.initialise = function(dimensions) {
      Demo.__super__.initialise.apply(this, arguments);
      this.height = dimensions.windowHeight;
      this.width = dimensions.windowWidth;
    };

    Demo.prototype.update = function(delta, time) {};

    Demo.prototype.resize = function(width, height) {
      this.width = width;
      this.height = height;
    };

    return Demo;

  })(Class);

  /* --------------------------------------------
       Begin Pathfinding.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Pathfinding
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  DEMOS.Pathfinding = (function(_super) {
    var ALGORITHMS, COLORS, GRID_OFFSET, GRID_STROKE, SOLUTION_CAP, SOLUTION_JOIN, SOLUTION_OFFSET, SOLUTION_STROKE;

    __extends(Pathfinding, _super);

    /*
      #========================================
      # Class Variables
      #========================================
    */


    function Pathfinding() {
      this.onMouseClick = __bind(this.onMouseClick, this);

      this.resize = __bind(this.resize, this);

      this.scale = __bind(this.scale, this);

      this.map = __bind(this.map, this);

      this.drawSolution = __bind(this.drawSolution, this);

      this.drawBlocks = __bind(this.drawBlocks, this);

      this.drawGrid = __bind(this.drawGrid, this);

      this.drawBackground = __bind(this.drawBackground, this);

      this.draw = __bind(this.draw, this);

      this.step = __bind(this.step, this);

      this.solve = __bind(this.solve, this);

      this.reset = __bind(this.reset, this);

      this.addControls = __bind(this.addControls, this);

      this.addEventListeners = __bind(this.addEventListeners, this);

      this.setProperties = __bind(this.setProperties, this);

      this.initialise = __bind(this.initialise, this);
      return Pathfinding.__super__.constructor.apply(this, arguments);
    }

    GRID_STROKE = 1;

    GRID_OFFSET = GRID_STROKE / 2;

    SOLUTION_STROKE = 10;

    SOLUTION_OFFSET = SOLUTION_STROKE / 2;

    SOLUTION_JOIN = 'round';

    SOLUTION_CAP = 'round';

    COLORS = {
      background: '#F3EEE8',
      grid: 'rgba(0,0,0,0.15)',
      wall: '#DD2222',
      start: '#4488DD',
      end: '#4488DD',
      opened: '#CCCCCD',
      closed: '#DDDDDD',
      failed: '#FF8888',
      solution: 'rgba(0,0,0,0.8)'
    };

    ALGORITHMS = ['AStar', 'BiAStar', 'BreadthFirst', 'BiBreadthFirst', 'BestFirst', 'BiBestFirst', 'Dijkstra', 'BiDijkstra', 'JumpPoint'];

    /*
      #========================================
      # Class Variables
      #========================================
    */


    Pathfinding["class"] = 'DEMOS.Pathfinding';

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    Pathfinding.prototype.$canvas = null;

    Pathfinding.prototype.gui = null;

    Pathfinding.prototype.canvas = null;

    Pathfinding.prototype.context = null;

    Pathfinding.prototype.allowDiagonal = null;

    Pathfinding.prototype.algorithm = null;

    Pathfinding.prototype.delay = null;

    Pathfinding.prototype.gridHeight = null;

    Pathfinding.prototype.gridWidth = null;

    Pathfinding.prototype.cellSize = null;

    Pathfinding.prototype.paddingX = null;

    Pathfinding.prototype.paddingY = null;

    Pathfinding.prototype.columns = null;

    Pathfinding.prototype.rows = null;

    Pathfinding.prototype.blocks = null;

    Pathfinding.prototype.walls = null;

    Pathfinding.prototype.operations = null;

    Pathfinding.prototype.operation = null;

    Pathfinding.prototype.solution = null;

    Pathfinding.prototype.start = null;

    Pathfinding.prototype.end = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    Pathfinding.prototype.initialise = function(dimensions) {
      Pathfinding.__super__.initialise.apply(this, arguments);
      Pathfinder.addHookOnNode();
      this.gui = new dat.GUI;
      this.$canvas = $('<canvas>').attr({
        width: this.width,
        height: this.height
      });
      this.canvas = this.$canvas.get(0);
      this.context = this.canvas.getContext('2d');
      this.$container.append(this.$canvas);
      this.setProperties();
      this.addEventListeners();
      this.addControls();
      this.reset();
    };

    Pathfinding.prototype.setProperties = function(dimensions) {
      this.algorithm = 'AStar';
      this.allowDiagonal = true;
      this.columns = 16;
      this.delay = 0.005;
    };

    Pathfinding.prototype.addEventListeners = function() {
      this.$canvas.on('click', this.onMouseClick);
    };

    Pathfinding.prototype.addControls = function() {
      var controller,
        _this = this;
      controller = this.gui.add(this, 'columns', 5, 50);
      controller.onChange(function(value) {
        return _this.reset();
      });
      controller.step(1);
      controller = this.gui.add(this, 'delay', 0, 0.2);
      controller.onChange(function(value) {
        return _this.solve();
      });
      controller = this.gui.add(this, 'algorithm', ALGORITHMS);
      controller.onChange(function(value) {
        return _this.solve();
      });
      controller = this.gui.add(this, 'allowDiagonal');
      controller.onChange(function(value) {
        return _this.solve();
      });
      controller = this.gui.add(this, 'solve');
      controller = this.gui.add(this, 'reset');
    };

    Pathfinding.prototype.reset = function() {
      var L, R, T;
      this.walls = [];
      this.blocks = [];
      this.solution = [];
      this.cellSize = Math.ceil(this.width / this.columns);
      this.rows = Math.ceil(this.height / this.cellSize);
      this.gridWidth = this.cellSize * this.columns;
      this.gridHeight = this.cellSize * this.rows;
      this.paddingX = Math.floor((this.width - this.gridWidth) / 2);
      this.paddingY = Math.floor((this.height - this.gridHeight) / 2);
      T = Math.floor((this.rows - 1) / 2);
      L = Math.floor((this.columns - 1) / 4);
      R = this.columns - L - 1;
      this.start = {
        x: L,
        y: T,
        index: L + T * this.columns
      };
      this.end = {
        x: R,
        y: T,
        index: R + T * this.columns
      };
      this.blocks[this.start.index] = COLORS.start;
      this.blocks[this.end.index] = COLORS.end;
      this.draw();
    };

    Pathfinding.prototype.solve = function() {
      var index, value, _i, _len, _ref;
      Pathfinder.initialise(this.columns, this.rows, Pathfinder.algorithms[this.algorithm], {
        allowDiagonal: this.allowDiagonal
      });
      _ref = this.walls;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        value = _ref[index];
        if (value != null) {
          Pathfinder.setWalkable(Pathfinder.indexToCoordinate(index));
        }
      }
      this.solution = Pathfinder.solution(this.start, this.end);
      TweenLite.killDelayedCallsTo(this.step);
      this.operation = 0;
      this.step();
    };

    Pathfinding.prototype.step = function() {
      var call;
      this.draw();
      call = this.operation < Pathfinder.operations.length;
      if (call) {
        TweenLite.delayedCall(this.delay, this.step);
      }
      this.operation++;
    };

    Pathfinding.prototype.draw = function() {
      this.drawBackground();
      this.drawBlocks();
      this.drawGrid();
      this.drawSolution();
    };

    Pathfinding.prototype.drawBackground = function() {
      this.context.fillStyle = COLORS.background;
      this.context.fillRect(0, 0, this.width, this.height);
    };

    Pathfinding.prototype.drawGrid = function() {
      var parameters, x, y, _i, _j, _ref, _ref1, _ref2;
      this.context.beginPath();
      parameters = [this.paddingX - GRID_OFFSET, this.paddingY - GRID_OFFSET, this.gridWidth + GRID_STROKE, this.gridHeight + GRID_STROKE];
      (_ref = this.context).rect.apply(_ref, parameters);
      for (x = _i = 1, _ref1 = this.columns; 1 <= _ref1 ? _i < _ref1 : _i > _ref1; x = 1 <= _ref1 ? ++_i : --_i) {
        this.context.moveTo(this.paddingX + GRID_OFFSET + x * this.cellSize, this.paddingY);
        this.context.lineTo(this.paddingX + GRID_OFFSET + x * this.cellSize, this.paddingY + this.gridHeight);
      }
      for (y = _j = 1, _ref2 = this.rows; 1 <= _ref2 ? _j < _ref2 : _j > _ref2; y = 1 <= _ref2 ? ++_j : --_j) {
        this.context.moveTo(this.paddingX, this.paddingY + GRID_OFFSET + y * this.cellSize);
        this.context.lineTo(this.paddingX + this.gridWidth, this.paddingY + GRID_OFFSET + y * this.cellSize);
      }
      this.context.strokeStyle = COLORS.grid;
      this.context.lineWidth = GRID_STROKE;
      this.context.stroke();
    };

    Pathfinding.prototype.drawBlocks = function() {
      var index, key, operation, point, value, _i, _len, _ref, _ref1;
      _ref = Pathfinder.operations;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        operation = _ref[index];
        if (!(index < this.operation)) {
          continue;
        }
        point = this.scale(operation.x, operation.y);
        this.context.fillStyle = COLORS[operation.attr];
        this.context.fillRect(point.x, point.y, this.cellSize, this.cellSize);
      }
      _ref1 = this.blocks;
      for (key in _ref1) {
        value = _ref1[key];
        if (!(value != null)) {
          continue;
        }
        point = this.map(key);
        this.context.fillStyle = value;
        this.context.fillRect(point.x, point.y, this.cellSize, this.cellSize);
      }
    };

    Pathfinding.prototype.drawSolution = function() {
      var index, method, offset, point, value, _i, _len, _ref;
      if (this.operation !== Pathfinder.operations.length) {
        return;
      }
      this.context.beginPath();
      _ref = this.solution;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        value = _ref[index];
        point = this.map(value);
        offset = Math.floor(this.cellSize / 2);
        point.x += offset;
        point.y += offset;
        method = index ? 'lineTo' : 'moveTo';
        this.context[method](point.x, point.y);
      }
      this.context.strokeStyle = COLORS.solution;
      this.context.lineWidth = SOLUTION_STROKE;
      this.context.lineJoin = SOLUTION_JOIN;
      this.context.lineCap = SOLUTION_CAP;
      this.context.stroke();
    };

    Pathfinding.prototype.map = function(index) {
      var x, y;
      x = index % this.columns;
      y = Math.floor(index / this.columns);
      return this.scale(x, y);
    };

    Pathfinding.prototype.scale = function(x, y) {
      x *= this.cellSize;
      x += this.paddingX;
      y *= this.cellSize;
      y += this.paddingY;
      return {
        x: x,
        y: y
      };
    };

    Pathfinding.prototype.resize = function(width, height) {
      this.width = width;
      this.height = height;
      this.$canvas.attr({
        width: this.width,
        height: this.height
      });
      this.reset();
    };

    /*
      #========================================
      # Callbacks
      #========================================
    */


    Pathfinding.prototype.onMouseClick = function(event) {
      var index, isEnd, isStart, isWall, x, y;
      x = Math.floor((event.pageX - this.paddingX) / this.cellSize);
      y = Math.floor((event.pageY - this.paddingY) / this.cellSize);
      index = x + y * this.columns;
      isStart = this.blocks[index] === COLORS.start;
      isEnd = this.blocks[index] === COLORS.end;
      isWall = this.blocks[index] === COLORS.wall;
      if (isStart || isEnd) {
        return;
      }
      this.blocks[index] = this.walls[index] = isWall ? null : COLORS.wall;
      this.draw();
    };

    return Pathfinding;

  })(DEMOS.Demo);

  /* --------------------------------------------
       Begin Projection.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Projection
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  DEMOS.Projection = (function(_super) {
    var DURATION, EASE;

    __extends(Projection, _super);

    /*
      #========================================
      # Constants
      #========================================
    */


    function Projection() {
      this.onBufferRendered = __bind(this.onBufferRendered, this);

      this.resize = __bind(this.resize, this);

      this.update = __bind(this.update, this);

      this.updateUniforms = __bind(this.updateUniforms, this);

      this.addParticles = __bind(this.addParticles, this);

      this.addDust = __bind(this.addDust, this);

      this.addControls = __bind(this.addControls, this);

      this.addEventListeners = __bind(this.addEventListeners, this);

      this.setProperties = __bind(this.setProperties, this);

      this.initialise = __bind(this.initialise, this);
      return Projection.__super__.constructor.apply(this, arguments);
    }

    DURATION = 4.0;

    EASE = Quad.easeInOut;

    /*
      #========================================
      # Class Variables
      #========================================
    */


    Projection["class"] = 'DEMOS.Projection';

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    Projection.prototype.buffer = null;

    Projection.prototype.scene = null;

    Projection.prototype.gui = null;

    Projection.prototype.attributes = null;

    Projection.prototype.uniforms = null;

    Projection.prototype.geometry = null;

    Projection.prototype.material = null;

    Projection.prototype.system = null;

    Projection.prototype.origin = null;

    Projection.prototype.dust = null;

    Projection.prototype.map = null;

    Projection.prototype.sphereRatio = null;

    Projection.prototype.cylinderRatio = null;

    Projection.prototype.displacement = null;

    Projection.prototype.autoRotation = null;

    Projection.prototype.showSource = null;

    Projection.prototype.scatter = null;

    Projection.prototype.color1 = null;

    Projection.prototype.color2 = null;

    Projection.prototype.alpha1 = null;

    Projection.prototype.alpha2 = null;

    Projection.prototype.cylinder = null;

    Projection.prototype.sphere = null;

    Projection.prototype.radius = null;

    Projection.prototype.offset = null;

    Projection.prototype.pulse = null;

    Projection.prototype.size = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    Projection.prototype.initialise = function(dimensions) {
      Projection.__super__.initialise.apply(this, arguments);
      this.gui = new dat.GUI;
      this.buffer = new DEMOS.ImageBuffer('/assets/images/elevation1080.png');
      this.scene = new DEMOS.Scene(this.width, this.height);
      this.scene.add(this.origin = new THREE.Object3D);
      this.$container.append(this.scene.$element);
      this.$container.append(this.scene.$vignetting);
      this.$container.append(this.scene.$lensflare);
      this.$container.append(this.scene.$scanlines);
      this.$container.append(this.buffer.$canvas);
      this.setProperties();
      this.addEventListeners();
      this.addControls();
      this.addDust();
    };

    Projection.prototype.setProperties = function() {
      this.displacement = 0.001;
      this.radius = 150;
      this.offset = 40;
      this.showSource = true;
      this.autoRotation = true;
      this.scatter = false;
      this.cylinder = false;
      this.sphere = false;
      this.pulse = false;
      this.cylinderRatio = 0.001;
      this.sphereRatio = 0.001;
      this.size = 2.0;
      this.color1 = '#FF4400';
      this.color2 = '#2266FF';
      this.alpha1 = 0.2;
      this.alpha2 = 0.4;
    };

    Projection.prototype.addEventListeners = function() {
      this.buffer.rendered.add(this.onBufferRendered);
    };

    Projection.prototype.addControls = function() {
      var controller,
        _this = this;
      controller = this.gui.add(this, 'showSource');
      controller.onChange(function(value) {
        if (value) {
          return _this.buffer.$canvas.removeClass('hide');
        } else {
          return _this.buffer.$canvas.addClass('hide');
        }
      });
      controller = this.gui.add(this, 'cylinder');
      controller.onChange(function(value) {
        return TweenLite.to(_this, DURATION, {
          onUpdate: function() {
            return _this.updateUniforms();
          },
          cylinderRatio: value ? 1 : 0,
          ease: EASE
        });
      });
      controller = this.gui.add(this, 'sphere');
      controller.onChange(function(value) {
        return TweenLite.to(_this, DURATION, {
          onUpdate: function() {
            return _this.updateUniforms();
          },
          sphereRatio: value ? 1 : 0,
          ease: EASE
        });
      });
      controller = this.gui.add(this, 'autoRotation');
      controller.onChange(function(value) {
        return _this.updateUniforms();
      });
      controller = this.gui.add(this, 'displacement', 0, 1);
      controller.onChange(function(value) {
        return _this.updateUniforms();
      });
      controller = this.gui.add(this, 'pulse');
      controller.onChange(function(value) {
        return _this.updateUniforms();
      });
      controller = this.gui.add(this, 'radius', 50, 400);
      controller.onChange(function(value) {
        return _this.updateUniforms();
      });
      controller = this.gui.add(this, 'offset', 0, 100);
      controller.onChange(function(value) {
        return _this.updateUniforms();
      });
      controller = this.gui.add(this, 'size', 1, 10);
      controller.onChange(function(value) {
        return _this.updateUniforms();
      });
      controller = this.gui.addColor(this, 'color1');
      controller.onChange(function(value) {
        return _this.updateUniforms();
      });
      controller = this.gui.add(this, 'alpha1', 0, 1);
      controller.onChange(function(value) {
        return _this.updateUniforms();
      });
      controller = this.gui.addColor(this, 'color2');
      controller.onChange(function(value) {
        return _this.updateUniforms();
      });
      controller = this.gui.add(this, 'alpha2', 0, 1);
      controller.onChange(function(value) {
        return _this.updateUniforms();
      });
      this.gui.close();
    };

    Projection.prototype.addDust = function() {
      this.dust = new DEMOS.Dust;
      this.dust.initialise(200, 600, 1000, this.width, this.height);
      this.scene.scene.add(this.dust);
    };

    Projection.prototype.addParticles = function(width, height, data) {
      var RESOLUTION, latitude, longitude, pixel, position, range, step, vertex, _i, _len;
      RESOLUTION = width / 360;
      this.map = THREE.ImageUtils.loadTexture('/assets/graphics/particle.png');
      this.attributes = SHADERS.Projection.cloneAttributes();
      this.uniforms = SHADERS.Projection.cloneUniforms();
      this.uniforms.uMap.value = this.map;
      this.geometry = new THREE.Geometry;
      this.material = new SHADERS.Projection({
        blending: THREE.AdditiveBlending,
        attributes: this.attributes,
        uniforms: this.uniforms,
        transparent: true,
        depthWrite: false,
        depthTest: true
      });
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        pixel = data[_i];
        step = Math.randomInRange(0, Math.PI * 2.0);
        latitude = 90 - pixel.y / RESOLUTION;
        longitude = (180 - pixel.x / RESOLUTION) * -1;
        position = new THREE.Vector3;
        position.x = pixel.x / width;
        position.y = pixel.y / height * -1;
        position.z = pixel.rgb;
        range = new THREE.Vector2;
        range.x = Math.randomInRange(0.0, 0.5);
        range.y = Math.randomInRange(0.5, 1.0);
        vertex = Map.project(latitude, longitude);
        this.attributes.aPosition.value.push(position);
        this.attributes.aRange.value.push(range);
        this.attributes.aStep.value.push(step);
        this.geometry.vertices.push(vertex);
      }
      this.system = new THREE.ParticleSystem(this.geometry, this.material);
      this.system.rotation.x = Math.degreesToRadians(-45);
      this.origin.add(this.system);
      this.updateUniforms();
    };

    Projection.prototype.updateUniforms = function() {
      if (this.uniforms != null) {
        this.uniforms.uColor1.value = Color.vector4(this.color1, this.alpha1);
        this.uniforms.uColor2.value = Color.vector4(this.color2, this.alpha2);
        this.uniforms.uScatter.value = this.scatter ? 1 : 0;
        this.uniforms.uPulse.value = this.pulse ? 1 : 0;
        this.uniforms.uDisplacement.value = this.displacement;
        this.uniforms.uCylinderRatio.value = this.cylinderRatio;
        this.uniforms.uSphereRatio.value = this.sphereRatio;
        this.uniforms.uScale.value = this.height / 2;
        this.uniforms.uRadius.value = this.radius;
        this.uniforms.uOffset.value = this.offset;
        this.uniforms.uSize.value = this.size;
      }
    };

    Projection.prototype.update = function(delta, time) {
      var _ref, _ref1, _ref2;
      if (this.uniforms != null) {
        this.uniforms.uTime.value = time;
      }
      if (this.autoRotation) {
        if ((_ref = this.origin) != null) {
          _ref.rotation.y += delta * 0.15;
        }
      }
      if ((_ref1 = this.dust) != null) {
        _ref1.update(delta, time);
      }
      if ((_ref2 = this.scene) != null) {
        _ref2.update(delta, time);
      }
    };

    Projection.prototype.resize = function(width, height) {
      var _ref, _ref1;
      this.width = width;
      this.height = height;
      if ((_ref = this.dust) != null) {
        _ref.resize(this.width, this.height);
      }
      if ((_ref1 = this.scene) != null) {
        _ref1.resize(this.width, this.height);
      }
      this.updateUniforms();
    };

    /*
      #========================================
      # Callbacks
      #========================================
    */


    Projection.prototype.onBufferRendered = function(width, height, data) {
      this.addParticles(width, height, data);
    };

    return Projection;

  })(DEMOS.Demo);

  /* --------------------------------------------
       Begin HeatmapCanvas.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: HeatmapCanvas
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  DEMOS.HeatmapCanvas = (function(_super) {

    __extends(HeatmapCanvas, _super);

    /*
      #========================================
      # Class Variables
      #========================================
    */


    HeatmapCanvas["class"] = 'DEMOS.HeatmapCanvas';

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    HeatmapCanvas.prototype.$element = null;

    HeatmapCanvas.prototype.$window = null;

    HeatmapCanvas.prototype.resolution = null;

    HeatmapCanvas.prototype.height = null;

    HeatmapCanvas.prototype.width = null;

    HeatmapCanvas.prototype.maskRendered = null;

    HeatmapCanvas.prototype.maskHeatmap = null;

    HeatmapCanvas.prototype.rendered = null;

    HeatmapCanvas.prototype.element = null;

    HeatmapCanvas.prototype.heatmap = null;

    HeatmapCanvas.prototype.context = null;

    HeatmapCanvas.prototype.canvas = null;

    HeatmapCanvas.prototype.buffer = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    function HeatmapCanvas(resolution) {
      this.resolution = resolution;
      this.onBufferRendered = __bind(this.onBufferRendered, this);

      this.onWindowMouseUp = __bind(this.onWindowMouseUp, this);

      this.onHeatmapMouseMove = __bind(this.onHeatmapMouseMove, this);

      this.onHeatmapMouseDown = __bind(this.onHeatmapMouseDown, this);

      this.onHeatmapMouseClick = __bind(this.onHeatmapMouseClick, this);

      this.generate = __bind(this.generate, this);

      this.clear = __bind(this.clear, this);

      this.render = __bind(this.render, this);

      this.setRadii = __bind(this.setRadii, this);

      this.addPoint = __bind(this.addPoint, this);

      this.mask = __bind(this.mask, this);

      this.visible = __bind(this.visible, this);

      this.addEventListeners = __bind(this.addEventListeners, this);

      this.maskHeatmap = false;
      this.maskRendered = false;
      this.width = 360 * this.resolution;
      this.height = 180 * this.resolution;
      this.buffer = new DEMOS.ImageBuffer("/assets/images/land" + this.width + ".png");
      this.rendered = new signals.Signal;
      this.$window = $(window);
      this.$output = $('<canvas class="output">').attr({
        width: this.width,
        height: this.height
      });
      this.$element = $('<div class="heatmap">');
      this.$element.css({
        width: this.width,
        height: this.height
      });
      this.$element.append(this.$output);
      this.element = this.$element.get(0);
      this.gradient = {};
      this.gradient['0.00'] = 'rgb( 0,   0,   255 )';
      this.gradient['0.25'] = 'rgb( 0,   255, 255 )';
      this.gradient['0.50'] = 'rgb( 0,   255, 0   )';
      this.gradient['0.75'] = 'rgb( 255, 255, 0   )';
      this.gradient['1.00'] = 'rgb( 255, 0,   0   )';
      this.heatmap = heatmapFactory.create({
        element: this.element,
        gradient: this.gradient
      });
      this.heatmapCanvas = this.heatmap.get('canvas');
      this.heatmapContext = this.heatmap.get('ctx');
      this.outputCanvas = this.$output.get(0);
      this.outputContext = this.outputCanvas.getContext('2d');
      this.addEventListeners();
      this.setRadii(5, 40);
      return;
    }

    HeatmapCanvas.prototype.addEventListeners = function() {
      this.$element.on('mousedown', this.onHeatmapMouseDown);
      this.$element.on('click', this.onHeatmapMouseClick);
      this.buffer.rendered.add(this.onBufferRendered);
    };

    HeatmapCanvas.prototype.visible = function(value) {
      if (value) {
        this.$element.removeClass('hide');
      } else {
        this.$element.addClass('hide');
      }
    };

    HeatmapCanvas.prototype.mask = function(value) {
      this.maskHeatmap = value;
      this.render();
    };

    HeatmapCanvas.prototype.addPoint = function(x, y) {
      this.heatmap.store.addDataPoint(x, y);
      this.render();
    };

    HeatmapCanvas.prototype.setRadii = function(inner, outer) {
      this.heatmap.set('radiusIn', inner);
      this.heatmap.set('radiusOut', outer);
      this.render();
    };

    HeatmapCanvas.prototype.render = function() {
      var multipliers, outputData, sourceData;
      multipliers = [];
      if (this.maskRendered && this.maskHeatmap) {
        multipliers.push(this.buffer.context.getImageData(0, 0, this.width, this.height));
      }
      sourceData = this.heatmapContext.getImageData(0, 0, this.width, this.height);
      outputData = Canvas.multiply(sourceData, multipliers);
      this.outputContext.putImageData(outputData, 0, 0);
      this.rendered.dispatch(outputData);
    };

    HeatmapCanvas.prototype.clear = function() {
      this.heatmap.clear();
      this.render();
    };

    HeatmapCanvas.prototype.generate = function(count) {
      this.heatmap.clear();
      this.heatmap.store.generateRandomDataSet(count);
      this.render();
    };

    /*
      #========================================
      # Callbacks
      #========================================
    */


    HeatmapCanvas.prototype.onHeatmapMouseClick = function(event) {
      this.addPoint(event.offsetX, event.offsetY);
    };

    HeatmapCanvas.prototype.onHeatmapMouseDown = function(event) {
      this.$element.on('mousemove', this.onHeatmapMouseMove);
      this.$window.on('mouseup', this.onWindowMouseUp);
    };

    HeatmapCanvas.prototype.onHeatmapMouseMove = function(event) {
      this.addPoint(event.offsetX, event.offsetY);
    };

    HeatmapCanvas.prototype.onWindowMouseUp = function(event) {
      this.$element.off('mousemove', this.onHeatmapMouseMove);
      this.$window.off('mouseup', this.onWindowMouseUp);
    };

    HeatmapCanvas.prototype.onBufferRendered = function(width, height, data) {
      this.maskRendered = true;
      this.render();
    };

    return HeatmapCanvas;

  })(Class);

  /* --------------------------------------------
       Begin Heatmap.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Heatmap
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  DEMOS.Heatmap = (function(_super) {
    var DELAY, RATIO, RESOLUTION;

    __extends(Heatmap, _super);

    /*
      #========================================
      # Constants
      #========================================
    */


    function Heatmap() {
      this.onHeatmapRendered = __bind(this.onHeatmapRendered, this);

      this.format = __bind(this.format, this);

      this.resize = __bind(this.resize, this);

      this.update = __bind(this.update, this);

      this.generatePoints = __bind(this.generatePoints, this);

      this.clearHeatmap = __bind(this.clearHeatmap, this);

      this.updateCage = __bind(this.updateCage, this);

      this.updateSpikes = __bind(this.updateSpikes, this);

      this.updateUniforms = __bind(this.updateUniforms, this);

      this.updateObjects = __bind(this.updateObjects, this);

      this.addSpikes = __bind(this.addSpikes, this);

      this.addParticles = __bind(this.addParticles, this);

      this.addCage = __bind(this.addCage, this);

      this.addDust = __bind(this.addDust, this);

      this.addControls = __bind(this.addControls, this);

      this.addEventListeners = __bind(this.addEventListeners, this);

      this.setProperties = __bind(this.setProperties, this);

      this.initialise = __bind(this.initialise, this);
      return Heatmap.__super__.constructor.apply(this, arguments);
    }

    RESOLUTION = 3;

    RATIO = 1 / RESOLUTION;

    DELAY = 500;

    /*
      #========================================
      # Class Variables
      #========================================
    */


    Heatmap["class"] = 'DEMOS.Heatmap';

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    Heatmap.prototype.debounce = null;

    Heatmap.prototype.scene = null;

    Heatmap.prototype.gui = null;

    Heatmap.prototype.particles = null;

    Heatmap.prototype.uniforms = null;

    Heatmap.prototype.heatmap = null;

    Heatmap.prototype.spikes = null;

    Heatmap.prototype.origin = null;

    Heatmap.prototype.cage = null;

    Heatmap.prototype.dust = null;

    Heatmap.prototype.autoRotation = null;

    Heatmap.prototype.displacement = null;

    Heatmap.prototype.maskHeatmap = null;

    Heatmap.prototype.showHeatmap = null;

    Heatmap.prototype.innerRadius = null;

    Heatmap.prototype.outerRadius = null;

    Heatmap.prototype.frequency = null;

    Heatmap.prototype.linewidth = null;

    Heatmap.prototype.alpha1 = null;

    Heatmap.prototype.alpha2 = null;

    Heatmap.prototype.alpha3 = null;

    Heatmap.prototype.pulse = null;

    Heatmap.prototype.size = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    Heatmap.prototype.initialise = function(dimensions) {
      Heatmap.__super__.initialise.apply(this, arguments);
      this.gui = new dat.GUI;
      this.debounce = _.debounce(this.format, DELAY);
      this.heatmap = new DEMOS.HeatmapCanvas(RESOLUTION);
      this.uniforms = SHADERS.Heatmap.cloneUniforms();
      this.uniforms.uMap.value = THREE.ImageUtils.loadTexture('/assets/graphics/particle.png');
      this.scene = new DEMOS.Scene(this.width, this.height);
      this.scene.add(this.origin = new THREE.Object3D);
      this.$container.append(this.scene.$element);
      this.$container.append(this.scene.$vignetting);
      this.$container.append(this.scene.$lensflare);
      this.$container.append(this.scene.$scanlines);
      this.$container.append(this.heatmap.$element);
      this.setProperties();
      this.addEventListeners();
      this.addControls();
      this.addDust();
      this.addCage();
      this.updateObjects();
    };

    Heatmap.prototype.setProperties = function() {
      this.innerRadius = 200;
      this.outerRadius = 260;
      this.linewidth = 1;
      this.size = 3.5;
      this.displacement = 0.01;
      this.frequency = 0.1;
      this.alpha1 = 0.55;
      this.alpha2 = 0.25;
      this.alpha3 = 0.05;
      this.autoRotation = true;
      this.maskHeatmap = false;
      this.showHeatmap = true;
      this.pulse = false;
    };

    Heatmap.prototype.addEventListeners = function() {
      this.heatmap.rendered.add(this.onHeatmapRendered);
    };

    Heatmap.prototype.addControls = function() {
      var controller,
        _this = this;
      controller = this.gui.add(this, 'clearHeatmap');
      controller = this.gui.add(this, 'generatePoints');
      controller = this.gui.add(this, 'maskHeatmap');
      controller.onChange(function(value) {
        return _this.heatmap.mask(value);
      });
      controller = this.gui.add(this, 'showHeatmap');
      controller.onChange(function(value) {
        return _this.heatmap.visible(value);
      });
      controller = this.gui.add(this, 'displacement', 0, 1);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'size', 0, 20);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'innerRadius', 0, 400);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'outerRadius', 0, 400);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'autoRotation');
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
    };

    Heatmap.prototype.addDust = function() {
      this.dust = new DEMOS.Dust;
      this.dust.initialise(200, 600, 1000, this.width, this.height);
      this.scene.scene.add(this.dust);
    };

    Heatmap.prototype.addCage = function() {
      var frame, geometry, globe, material;
      material = new THREE.MeshBasicMaterial({
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
        transparent: true,
        depthWrite: false,
        depthTest: true,
        wireframe: true,
        color: 0xFFFFFF,
        opacity: 0.02
      });
      geometry = new THREE.SphereGeometry(1, 80, 40);
      THREE.GeometryUtils.triangulateQuads(geometry);
      frame = new THREE.Mesh(geometry, material);
      material = new THREE.MeshBasicMaterial({
        map: THREE.ImageUtils.loadTexture('/assets/images/land1080.png'),
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
        transparent: true,
        depthWrite: false,
        depthTest: true,
        color: 0xFFFFFF,
        opacity: 0.08
      });
      geometry = new THREE.SphereGeometry(1, 80, 40);
      globe = new THREE.Mesh(geometry, material);
      this.cage = new THREE.Object3D;
      this.cage.add(frame);
      this.cage.add(globe);
      this.cage.scale.set(this.innerRadius, this.innerRadius, this.innerRadius);
      this.origin.add(this.cage);
    };

    Heatmap.prototype.addParticles = function(width, height, data) {
      var attributes, color, geometry, hue, index, latitude, longitude, material, normal, pixel, vertex, _i, _len;
      if (this.particles != null) {
        this.origin.remove(this.particles);
        this.scene.renderer.deallocateObject(this.particles);
      }
      attributes = SHADERS.Heatmap.cloneAttributes();
      geometry = new THREE.Geometry;
      material = new SHADERS.Heatmap({
        blending: THREE.AdditiveBlending,
        attributes: attributes,
        linewidth: this.linewidth,
        uniforms: this.uniforms,
        transparent: true,
        depthWrite: false,
        depthTest: true
      });
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        pixel = data[index];
        latitude = pixel.y * RATIO + 90;
        longitude = pixel.x * RATIO - 180;
        normal = Map.project(latitude, longitude, 1);
        vertex = Map.project(latitude, longitude, pixel.rgb);
        color = new THREE.Vector4(pixel.r, pixel.g, pixel.b, pixel.a);
        hue = new THREE.Vector3(pixel.h, pixel.s, pixel.v);
        attributes.aNormal.value.push(normal);
        attributes.aColor.value.push(color);
        attributes.aHue.value.push(hue);
        attributes.aType.value.push(0);
        geometry.vertices.push(vertex);
      }
      this.particles = new THREE.ParticleSystem(geometry, material);
      this.origin.add(this.particles);
      this.updateObjects();
    };

    Heatmap.prototype.addSpikes = function(width, height, data) {
      var attributes, color, geometry, hue, index, latitude, longitude, material, normal, pixel, vertex, _i, _len;
      if (this.spikes != null) {
        this.origin.remove(this.spikes);
        this.scene.renderer.deallocateObject(this.spikes);
      }
      attributes = SHADERS.Heatmap.cloneAttributes();
      geometry = new THREE.Geometry;
      material = new SHADERS.Heatmap({
        blending: THREE.AdditiveBlending,
        attributes: attributes,
        linewidth: this.linewidth,
        uniforms: this.uniforms,
        transparent: true,
        depthWrite: false,
        depthTest: true
      });
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        pixel = data[index];
        latitude = pixel.y * RATIO + 90;
        longitude = pixel.x * RATIO - 180;
        normal = Map.project(latitude, longitude, 1);
        vertex = Map.project(latitude, longitude, pixel.rgb);
        color = new THREE.Vector4(pixel.r, pixel.g, pixel.b, pixel.a);
        hue = new THREE.Vector3(pixel.h, pixel.s, pixel.v);
        attributes.aNormal.value.push(normal, normal);
        attributes.aColor.value.push(color, color);
        attributes.aHue.value.push(hue, hue);
        attributes.aType.value.push(1, 2);
        geometry.vertices.push(vertex, vertex);
      }
      this.spikes = new THREE.Line(geometry, material, THREE.LinePieces);
      this.origin.add(this.spikes);
      this.updateObjects();
    };

    Heatmap.prototype.updateObjects = function() {
      this.updateUniforms();
      this.updateSpikes();
      this.updateCage();
    };

    Heatmap.prototype.updateUniforms = function() {
      if (this.uniforms != null) {
        this.uniforms.uRadii.value.set(this.innerRadius, this.outerRadius);
        this.uniforms.uAlpha.value.set(this.alpha1, this.alpha2, this.alpha3);
        this.uniforms.uDisplacement.value = this.displacement;
        this.uniforms.uFrequency.value = this.frequency;
        this.uniforms.uScale.value = this.height / 2;
        this.uniforms.uSize.value = this.size;
      }
    };

    Heatmap.prototype.updateSpikes = function() {
      if (this.spikes != null) {
        this.spikes.material.linewidth = this.linewidth;
      }
    };

    Heatmap.prototype.updateCage = function() {
      if (this.cage != null) {
        this.cage.scale.set(this.innerRadius, this.innerRadius, this.innerRadius);
      }
    };

    Heatmap.prototype.clearHeatmap = function() {
      var _ref;
      if ((_ref = this.heatmap) != null) {
        _ref.clear();
      }
    };

    Heatmap.prototype.generatePoints = function() {
      var _ref;
      if ((_ref = this.heatmap) != null) {
        _ref.generate(100);
      }
    };

    Heatmap.prototype.update = function(delta, time) {
      var _ref, _ref1;
      if (this.uniforms != null) {
        if (this.pulse) {
          this.uniforms.uTime.value = time;
        }
      }
      if (this.autoRotation && (this.origin != null)) {
        this.origin.rotation.x = 0.2 + 0.2 * Math.sin(time * 0.5);
        this.origin.rotation.y += delta * 0.2;
      }
      if ((_ref = this.dust) != null) {
        _ref.update(delta, time);
      }
      if ((_ref1 = this.scene) != null) {
        _ref1.update(delta, time);
      }
    };

    Heatmap.prototype.resize = function(width, height) {
      var _ref, _ref1;
      this.width = width;
      this.height = height;
      if ((_ref = this.dust) != null) {
        _ref.resize(this.width, this.height);
      }
      if ((_ref1 = this.scene) != null) {
        _ref1.resize(this.width, this.height);
      }
      this.updateObjects();
    };

    Heatmap.prototype.format = function(data) {
      data = Canvas.format(data, true, true, 0.5);
      this.addParticles(data.width, data.height, data);
      this.addSpikes(data.width, data.height, data);
    };

    /*
      #========================================
      # Callbacks
      #========================================
    */


    Heatmap.prototype.onHeatmapRendered = function(data) {
      this.debounce(data);
    };

    return Heatmap;

  })(DEMOS.Demo);

  /* --------------------------------------------
       Begin Noise.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Noise
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  DEMOS.Noise = (function(_super) {
    var SEGMENTS;

    __extends(Noise, _super);

    /*
      #========================================
      # Constants
      #========================================
    */


    function Noise() {
      this.resize = __bind(this.resize, this);

      this.update = __bind(this.update, this);

      this.updateCage = __bind(this.updateCage, this);

      this.updateUniforms = __bind(this.updateUniforms, this);

      this.updateObjects = __bind(this.updateObjects, this);

      this.addParticles = __bind(this.addParticles, this);

      this.addCage = __bind(this.addCage, this);

      this.addDust = __bind(this.addDust, this);

      this.addControls = __bind(this.addControls, this);

      this.setProperties = __bind(this.setProperties, this);

      this.initialise = __bind(this.initialise, this);
      return Noise.__super__.constructor.apply(this, arguments);
    }

    SEGMENTS = 100;

    /*
      #========================================
      # Class Variables
      #========================================
    */


    Noise["class"] = 'DEMOS.Noise';

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    Noise.prototype.scene = null;

    Noise.prototype.gui = null;

    Noise.prototype.attributes = null;

    Noise.prototype.uniforms = null;

    Noise.prototype.geometry = null;

    Noise.prototype.material = null;

    Noise.prototype.terrain = null;

    Noise.prototype.origin = null;

    Noise.prototype.cage = null;

    Noise.prototype.dust = null;

    Noise.prototype.autoRotation = null;

    Noise.prototype.displacement = null;

    Noise.prototype.frequency = null;

    Noise.prototype.color1 = null;

    Noise.prototype.color2 = null;

    Noise.prototype.alpha1 = null;

    Noise.prototype.alpha2 = null;

    Noise.prototype.noiseX = null;

    Noise.prototype.noiseY = null;

    Noise.prototype.noiseZ = null;

    Noise.prototype.noiseW = null;

    Noise.prototype.range = null;

    Noise.prototype.pulse = null;

    Noise.prototype.depth = null;

    Noise.prototype.size = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    Noise.prototype.initialise = function(dimensions) {
      Noise.__super__.initialise.apply(this, arguments);
      this.gui = new dat.GUI;
      this.scene = new DEMOS.Scene(this.width, this.height);
      this.scene.add(this.origin = new THREE.Object3D);
      this.$container.append(this.scene.$element);
      this.$container.append(this.scene.$vignetting);
      this.$container.append(this.scene.$lensflare);
      this.$container.append(this.scene.$scanlines);
      this.setProperties();
      this.addControls();
      this.addParticles();
      this.addDust();
      this.addCage();
      this.updateObjects();
    };

    Noise.prototype.setProperties = function() {
      this.size = 400;
      this.depth = 240;
      this.displacement = 0.001;
      this.color1 = '#FF4400';
      this.color2 = '#8866FF';
      this.alpha1 = 0.2;
      this.alpha2 = 0.2;
      this.autoRotation = true;
      this.pulse = false;
      this.frequency = 0.1;
      this.noiseX = 1.0;
      this.noiseY = 0.6;
      this.noiseZ = 0.4;
      this.noiseW = 0.2;
      this.range = 4.2;
    };

    Noise.prototype.addControls = function() {
      var controller,
        _this = this;
      controller = this.gui.add(this, 'size', 100, 1000);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'depth', 100, 1000);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'displacement', 0, 1);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'range', 0, 10);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'pulse');
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'frequency', 0, 1);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'noiseX', 0, 1);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'noiseY', 0, 1);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'noiseZ', 0, 1);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'noiseW', 0, 1);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.addColor(this, 'color1');
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'alpha1', 0, 1);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.addColor(this, 'color2');
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'alpha2', 0, 1);
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
      controller = this.gui.add(this, 'autoRotation');
      controller.onChange(function(value) {
        return _this.updateObjects();
      });
    };

    Noise.prototype.addDust = function() {
      this.dust = new DEMOS.Dust;
      this.dust.initialise(200, 600, 1000, this.width, this.height);
      this.scene.scene.add(this.dust);
    };

    Noise.prototype.addCage = function() {
      var geometry, material, segments;
      material = new THREE.MeshBasicMaterial({
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
        transparent: true,
        depthWrite: false,
        depthTest: true,
        wireframe: true,
        color: 0xFFFFFF,
        opacity: 0.05
      });
      segments = 10;
      geometry = new THREE.CubeGeometry(1, 1, 1, segments, segments, segments);
      this.cage = new THREE.Mesh(geometry, material);
      this.cage.scale.set(this.size, this.depth, this.size);
      this.origin.add(this.cage);
    };

    Noise.prototype.addParticles = function() {
      this.attributes = SHADERS.Noise.cloneAttributes();
      this.uniforms = SHADERS.Noise.cloneUniforms();
      this.geometry = new THREE.PlaneGeometry(1, 1, SEGMENTS, SEGMENTS);
      THREE.GeometryUtils.triangulateQuads(this.geometry);
      this.material = new SHADERS.Noise({
        blending: THREE.AdditiveBlending,
        attributes: this.attributes,
        side: THREE.DoubleSide,
        uniforms: this.uniforms,
        transparent: true,
        depthWrite: false,
        depthTest: true,
        wireframe: true
      });
      this.terrain = new THREE.Mesh(this.geometry, this.material);
      this.origin.add(this.terrain);
    };

    Noise.prototype.updateObjects = function() {
      this.updateUniforms();
      this.updateCage();
    };

    Noise.prototype.updateUniforms = function() {
      if (this.uniforms != null) {
        this.uniforms.uNoise.value.set(this.noiseX, this.noiseY, this.noiseZ, this.noiseW);
        this.uniforms.uColor1.value = Color.vector4(this.color1, this.alpha1);
        this.uniforms.uColor2.value = Color.vector4(this.color2, this.alpha2);
        this.uniforms.uSize.value.set(this.size, this.depth, this.size);
        this.uniforms.uDisplacement.value = this.displacement;
        this.uniforms.uRange.value.set(-this.range, this.range);
        this.uniforms.uFrequency.value = this.frequency;
      }
    };

    Noise.prototype.updateCage = function() {
      if (this.cage != null) {
        this.cage.scale.set(this.size, this.depth, this.size);
      }
    };

    Noise.prototype.update = function(delta, time) {
      var _ref, _ref1;
      if (this.uniforms != null) {
        if (this.pulse) {
          this.uniforms.uTime.value = time;
        }
      }
      if (this.autoRotation && (this.origin != null)) {
        this.origin.rotation.x = 0.2 + 0.2 * Math.sin(time * 0.5);
        this.origin.rotation.y += delta * 0.2;
      }
      if ((_ref = this.dust) != null) {
        _ref.update(delta, time);
      }
      if ((_ref1 = this.scene) != null) {
        _ref1.update(delta, time);
      }
    };

    Noise.prototype.resize = function(width, height) {
      var _ref, _ref1;
      this.width = width;
      this.height = height;
      if ((_ref = this.dust) != null) {
        _ref.resize(this.width, this.height);
      }
      if ((_ref1 = this.scene) != null) {
        _ref1.resize(this.width, this.height);
      }
      this.updateObjects();
    };

    return Noise;

  })(DEMOS.Demo);

  /* --------------------------------------------
       Begin Main.coffee
  --------------------------------------------
  */


  /*
  #============================================================
  #
  # Prototype: Main Class
  #
  # @author Matthew Wagerfield
  #
  #============================================================
  */


  PROJECT.Main = (function(_super) {

    __extends(Main, _super);

    /*
      #========================================
      # Constants
      #========================================
    */


    /*
      #========================================
      # Class Variables
      #========================================
    */


    Main["class"] = 'PROJECT.Main';

    /*
      #========================================
      # Instance Variables
      #========================================
    */


    Main.prototype.$window = null;

    Main.prototype.$document = null;

    Main.prototype.$container = null;

    Main.prototype.$html = null;

    Main.prototype.$body = null;

    Main.prototype.layout = null;

    Main.prototype.clock = null;

    Main.prototype.delta = null;

    Main.prototype.time = null;

    Main.prototype.demo = null;

    Main.prototype.raf = null;

    /*
      #========================================
      # Instance Methods
      #========================================
    */


    function Main() {
      this.onLayoutResized = __bind(this.onLayoutResized, this);

      this.update = __bind(this.update, this);

      this.animate = __bind(this.animate, this);

      this.addDemo = __bind(this.addDemo, this);

      this.addEventListeners = __bind(this.addEventListeners, this);

      this.addClasses = __bind(this.addClasses, this);

      this.initialise = __bind(this.initialise, this);
      this.$window = $(window);
      this.$document = $(document);
      this.$container = $('#container');
      this.$html = $('html');
      this.$body = $('body');
      return;
    }

    Main.prototype.initialise = function() {
      Main.__super__.initialise.apply(this, arguments);
      this.addClasses();
      this.addEventListeners();
      this.addDemo();
      this.animate();
    };

    Main.prototype.addClasses = function() {
      this.layout = new Layout;
      this.layout.initialise();
      this.clock = new THREE.Clock;
    };

    Main.prototype.addEventListeners = function() {
      this.layout.resized.add(this.onLayoutResized);
    };

    Main.prototype.addDemo = function() {
      var className, demoName;
      demoName = window.location.href.replace(/.*demo=/, '');
      className = (demoName.charAt(0)).toUpperCase() + demoName.slice(1);
      log('demo:', demoName);
      log('class:', className);
      this.demo = new DEMOS[className](this.$container);
      this.demo.initialise(this.layout.dimensions());
    };

    Main.prototype.animate = function() {
      this.raf = requestAnimationFrame(this.animate);
      this.delta = this.clock.getDelta();
      this.time = this.clock.elapsedTime;
      this.update(this.delta, this.time);
    };

    Main.prototype.update = function(delta, time) {
      var _ref;
      if ((_ref = this.demo) != null) {
        _ref.update(delta, time);
      }
    };

    /*
      #========================================
      # Callbacks
      #========================================
    */


    Main.prototype.onLayoutResized = function(dimensions) {
      var _ref;
      if ((_ref = this.demo) != null) {
        _ref.resize(dimensions.windowWidth, dimensions.windowHeight);
      }
    };

    return Main;

  })(Class);

  this.DEMO = DEMO = new PROJECT.Main;

  /* --------------------------------------------
       Begin scripts.coffee
  --------------------------------------------
  */


  $(function() {
    return DEMO.initialise();
  });

}).call(this);
